<?php
/**
 * @file
 * Form definitions for admin forms.
 */

/**
 * Form callback; changeset preview form.
 */
function cps_changeset_preview_form($form, &$form_state) {
  $changeset_id = cps_get_current_changeset(TRUE);

  if ($changeset_id == CPS_PUBLISHED_CHANGESET) {
    $changeset_state = 'live';
  }
  else {
    $changeset = cps_changeset_load($changeset_id);
    $changeset_state = $changeset->status;
    $changeset_mine = $changeset->uid == $GLOBALS['user']->uid;
  }

  $form['#attached']['css'][] =  drupal_get_path('module', 'cps') . '/css/cps.css';

  $form['#type'] = 'fieldset';
  $form['#title'] = t('Site version:');
  $form['#description'] = t('Preview the site in the context of this site version.');

  $form['changeset_id'] = array(
    '#type' => 'select',
    '#title' => t('Site version'),
    '#options' => cps_get_changesets(),
    '#default_value' => $changeset_id,
  );

  if (!empty($changeset) && entity_access('view', 'cps_changeset', $changeset)) {
    $uri = $changeset->uri();
    $form['configure'] = array(
      '#markup' => l(t('Site version'), $uri['path'], array(
        'attributes' => array(
          'class' => array('configure'),
          'title' => t('Manage site version'),
        ))),
    );
  }

  if ($changeset_state == 'live') {
    $form['new'] = array(
      '#markup' => l(t('Create'), 'admin/structure/changesets/add', array(
        'query' => drupal_get_destination(),
        'attributes' => array(
          'class' => array('new'),
          'title' => t('Add new site version'),
        ))),
    );
  }

  $state_class = 'cps-preview-form--' . drupal_html_class($changeset_state);
  $mine_class = !empty($changeset_mine) ? 'cps-changeset--mine' : 'cps-changeset--not-mine';
  $form['#prefix'] = '<div class="cps-preview-form ' . $state_class . ' ' . $mine_class . ' clearfix">';
  $form['#suffix'] = '<span class="cps-preview-form-status">' . t('Status:  @changeset_status', array('@changeset_status' => ucfirst($changeset_state))) . '</span></div>';
  return $form;
}

/**
 * Basic edit form for the content entity.
 *
 * The entity being edited should be stored in $form_state['entity']
 * when this form is built.
 *
 * The name of this form is autogenerated as $entity_type . '_edit_form'.
 */
function cps_changeset_edit_form($form, &$form_state) {
  $entity = $form_state['entity'];

  $form['info']['name'] = array(
    '#type' => 'textfield',
    '#title' => t('Name'),
    '#description' => t('This will appear in the administrative interface to easily identify it.'),
    '#default_value' => $entity->name,
    '#required' => TRUE,
  );

  $form['info']['description'] = array(
    '#type' => 'textarea',
    '#title' => t('Description'),
    '#default_value' => $entity->description,
  );

  $form['actions'] = array(
    '#type' => 'actions',
  );

  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );

  return $form;
}

/**
 * Validate callback for the content entity.
 */
function cps_changeset_edit_form_validate($form, &$form_state) {
}

/**
 * Submit callback for the content entity.
 */
function cps_changeset_edit_form_submit($form, &$form_state) {
  $entity = $form_state['entity'];
  $entity->name = $form_state['values']['name'];
  $entity->description = $form_state['values']['description'];

  if (!empty($entity->is_new)) {
    // Automatically move us to the new changeset context.
    cps_set_current_changeset($entity->changeset_id);

    // If there is a destination, we have to remove the changeset ID from it.
    if (!empty($_GET['destination'])) {
      // We used drupal_get_destination() before because it may not have been
      // calculated; to directly modify it we will then need to get the
      // (now cached) static.
      $_GET['destination'] = preg_replace("/changeset_id=[^&]+/", 'changeset_id=' . $entity->changeset_id, $_GET['destination']);
    }
  }
}

/**
 * Form callback to display the publish changeset form.
 */
function cps_changeset_publish_changeset_form($form, &$form_state) {
  $form['warning'] = array(
    '#markup' => '<div class="publish-warning">' . t('Are you sure you want to publish this? This action cannot be undone!') . '</div>',
  );

  $form['actions']['publish'] = array(
    '#type' => 'submit',
    '#value' => t('Publish'),
  );

  $form['actions']['cancel'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel'),
    '#limit_validation_errors' => array(),
    '#submit' => array('cps_changeset_publish_changeset_form_cancel'),
  );

  return $form;
}

/**
 * Submit handler to cancel the form.
 */
function cps_changeset_publish_changeset_form_cancel($form, &$form_state) {
  $form_state['redirect'] = $form_state['entity']->uri();
}

/**
 * Submit handler for the publish changeset form.
 */
function cps_changeset_publish_changeset_form_submit($form, &$form_state) {
  // This is handled as a traditional submit method rather than my usual
  // preference of divorcing work from the form itself due to the nature
  // of batch API.

  // Create a list of entity ids in a format that the batch can use.
  $entity_ids = array();
  $entities = $form_state['entity']->getChangedEntities();
  foreach ($entities as $entity_type => $changed_entities) {
    foreach ($changed_entities as $entity_id => $entity) {
      $entity_ids[] = array($entity_type, $entity_id);
    }
  }
  $batch = array(
    'operations' => array(
      array('cps_changeset_publish_batch_lock', array()),
      array('cps_changeset_publish_batch_entities', array($entity_ids, $form_state['entity'])),
    ),
    'finished' => 'cps_changeset_publish_batch_finished',
    'title' => t('Publishing %changeset', array('%changeset' => $form_state['entity']->name)),
    'file' => drupal_get_path('module', 'cps') . '/includes/forms.inc',
  );

  if (variable_get('cps_override_variables', FALSE)) {
    $batch['operations'][] = array('cps_changeset_publish_batch_variables', array());
  }

  $plugins = cps_get_entity_plugins();
  foreach ($plugins as $entity_type => $plugin) {
    // For every entity type we support, add another operation for that entity type.
    $batch['operations'][] = array('cps_changeset_publish_batch_update', array($entity_type));
  }

  drupal_alter('cps_publish_changeset_batch', $batch, $form_state);

  batch_set($batch);

  $form_state['redirect'] = $form_state['entity']->uri();
}


/**
 * Batch API callback to acquire a lock for publishing.
 *
 * @param $entity_ids
 *   An array of arrays. Each entry in the array is first entity_type, then entity_id.
 * @param $changeset
 * @param $context
 */
function cps_changeset_publish_batch_lock(&$context) {
  if (cps_publish_lock()) {
    $context['finished'] = TRUE;
  }
  else {
    sleep(1);
    $context['finished'] = FALSE;
    $context['message'] = t('Waiting for lock: @time', array('@time' => format_interval(cps_publish_lock_time())));
  }
}

/**
 * Batch API callback to publish the entities in a changeset.
 *
 * @param $entity_ids
 *   An array of arrays. Each entry in the array is first entity_type, then entity_id.
 * @param $changeset
 * @param $context
 */
function cps_changeset_publish_batch_entities($entity_ids, $changeset, &$context) {
  // Use the $context['sandbox'] at your convenience to store the
  // information needed to track progression between successive calls.
  if (empty($context['sandbox'])) {
    $context['sandbox'] = array();
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_item'] = 0;
    $context['results']['entity'] = $changeset;
  }

  // Ensure that entities are loaded in the correct changeset.
  cps_override_changeset($changeset->changeset_id);

  $count = count($entity_ids);
  foreach (range(0, 2) as $i) {
    // Make sure long-saving content still saves okay.
    drupal_set_time_limit(60);
    $index = $context['sandbox']['current_item']++;
    // If our index no longer exists...
    if (!isset($entity_ids[$index])) {
      $context['finished'] = TRUE;
      break;
    }

    $context['finished'] = FALSE;
    list($entity_type, $entity_id) = $entity_ids[$index];
    $handler = cps_entity_plugin_get_handler($entity_type);
    if ($handler) {
      $handler->makeChangesetRevisionPublished($entity_id, $changeset->changeset_id);
    }
    $context['sandbox']['progress']++;
    $context['message'] = nt('Publishing item @index of @count', array('@index' => $index, '@count' => $count));
  }
  cps_override_changeset(NULL);
}

/**
 * Batch API callback to publish the variables in a changeset.
 */
function cps_changeset_publish_batch_variables(&$context) {
  $item = $context['results']['entity'];
  foreach ($item->variables as $name => $value) {
    db_merge('variable')->key(array('name' => $name))->fields(array('value' => serialize($value)))->execute();
  }
  cache_clear_all('variables', 'cache_bootstrap');
  $context['message'] = t('Publishing variables');
}

/**
 * Batch API callback to put in changeset markers for items that exist but didn't change.
 * @param $entity_type
 * @param $context
 */
function cps_changeset_publish_batch_update($entity_type, &$context) {
  // Use the $context['sandbox'] at your convenience to store the
  // information needed to track progression between successive calls.
  if (empty($context['sandbox'])) {
    $entity_info = entity_get_info($entity_type);
    $context['sandbox'] = array();
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_item'] = 0;
    $context['message'] = t('Marking unchanged @entity_type content', array('@entity_type' => $entity_info['label']));
  }

  $count = 0;
  $limit = 100;
  // We should be able to process a lot of these at a time.
  try {
    $query = new EntityFieldQuery();
    $results = $query
      ->entityCondition('entity_type', $entity_type)
      ->range($context['sandbox']['current_item'], $limit)
      ->execute();
    $context['sandbox']['progress']++;
  }
  catch (Exception $e) {
  }


  if (!empty($results[$entity_type])) {
    $count = count($results[$entity_type]);
    $handler = cps_entity_plugin_get_handler($entity_type);
    $handler->cps_revision_reset = TRUE;

    // Load which entities have revisions.
    $result = db_query('SELECT * FROM {cps_entity} WHERE entity_type = :entity_type AND entity_id IN (:entity_id) AND changeset_id = :changeset',
      array(
        ':entity_type' => $entity_type,
        ':entity_id' => array_keys($results[$entity_type]),
        ':changeset' => $context['results']['entity']->changeset_id,
      ));

    $used = array();
    while ($record = $result->fetchObject()) {
      $used[$record->entity_id] = TRUE;
    }

    foreach (entity_load($entity_type, array_keys($results[$entity_type])) as $entity) {

      list($entity_id, $revision_id,) = entity_extract_ids($entity_type, $entity);
      if (empty($used[$entity_id])) {
        db_insert('cps_entity')
          ->fields(array(
            'entity_type' => $entity_type,
            'entity_id' => $entity_id,
            'revision_id' => $revision_id,
            'changeset_id' => $context['results']['entity']->changeset_id,
            'published' => 1,
          ))
          ->execute();
      }
    }
    $handler->cps_revision_reset = FALSE;
  }

  if ($count < $limit) {
    $context['finished'] = TRUE;
  }
  else {
    $context['finished'] = FALSE;
    $context['sandbox']['current_item'] += $limit;
  }
}

/**
 * Batch API callback to finish the submission.
 *
 * @param $success
 * @param $results
 * @param $operations
 */
function cps_changeset_publish_batch_finished($success, $results, $operations) {
  if ($success) {
    // Set the publication time on the item. We have to GET the item somehow.
    $results['entity']->published = REQUEST_TIME;
    $results['entity']->setStatus('archived');
    if (variable_get('cps_override_variables', FALSE)) {

      // Rebuild the variables in the same manner that the cache is built from variable_initialize.
      $results['entity']->variables = array_map('unserialize', db_query('SELECT name, value FROM {variable}')->fetchAllKeyed());
      // Go through and unset any whitelisted variables so that they aren't stored in the archive.
      foreach ($results['entity']->variables as $name => $value) {
        if (strpos($name, 'cache') !== FALSE) {
          unset($results['entity']->variables[$name]);
        }
      }
    }

    $results['entity']->save();

    module_invoke_all('cps_changeset_published', $results['entity'], 'published');

    // Switch them to the published changeset.
    cps_set_current_changeset(NULL);

    drupal_set_message(t('The site version %changeset has been published.', array('%changeset' => $results['entity']->name)));
  }

  cps_publish_unlock();
}

// -----------------------------------------------------------------------
// Unpublish form and handlers.

/**
 * Form callback to display the unpublish changeset form.
 */
function cps_changeset_unpublish_changeset_form($form, &$form_state) {
  $entity = $form_state['entity'];
  $form_state['previous'] = cps_changeset_load($entity->getPreviousChangeset());

  $form['warning'] = array(
    '#markup' => '<div class="unpublish-warning">' . t('<p>Are you sure you want to unpublish this?</p><p> This will revert content to the previous site version "%changeset".</p>', array('%changeset' => $form_state['previous']->name)) . '</div>',
  );

  $form['actions']['unpublish'] = array(
    '#type' => 'submit',
    '#value' => t('Revert'),
  );

  $form['actions']['cancel'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel'),
    '#limit_validation_errors' => array(),
    // We re-use the publish_changeset_form_cancel here because all it does is redirect.
    '#submit' => array('cps_changeset_publish_changeset_form_cancel'),
  );

  return $form;
}

/**
 * Submit handler for the unpublish changeset form.
 */
function cps_changeset_unpublish_changeset_form_submit($form, &$form_state) {
  // We have to tell batch where to include this file.
  $batch = array(
    'operations' => array(
      array('cps_changeset_publish_batch_lock', array()),
      array('cps_changeset_unpublish_batch_variables', array($form_state['entity'], $form_state['previous'])),
    ),
    'finished' => 'cps_changeset_unpublish_batch_finished',
    'title' => t('Reverting %changeset', array('%changeset' => $form_state['entity']->name)),
    'file' => drupal_get_path('module', 'cps') . '/includes/forms.inc',
  );

  $plugins = cps_get_entity_plugins();
  foreach ($plugins as $entity_type => $plugin) {
    // For every entity type we support, add another operation for that entity type.
    $batch['operations'][] = array('cps_changeset_unpublish_batch_entity', array($entity_type));
  }

  drupal_alter('cps_unpublish_changeset_batch', $batch, $form_state);

  batch_set($batch);

  $form_state['redirect'] = $form_state['entity']->uri();
}

/**
 * Batch API callback to unpublish the entities in a changeset.
 */
function cps_changeset_unpublish_batch_variables($item, $previous, &$context) {
  // Use the $context['sandbox'] at your convenience to store the
  // information needed to track progression between successive calls.
  if (empty($context['sandbox'])) {
    $context['sandbox'] = array();
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_item'] = 0;
    $context['results']['entity'] = $item;
    $context['results']['previous'] = $previous;
  }

  if (variable_get('cps_override_variables', FALSE)) {

    $result = db_query("SELECT name, value FROM {variable}");
    $all_variables = array();
    while ($var = $result->fetchObject()) {
      $all_variables[$var->name] = unserialize($var->value);
    }

    foreach ($all_variables as $name => $value) {
      if (isset($previous->variables[$name]) && $previous->variables[$name] != $value) {
        db_merge('variable')->key(array('name' => $name))->fields(array('value' => serialize($previous->variables[$name])))->execute();
      }
      else {
        // If a variable is unchanged, unset it so we won't mistakenly report it as a change in the
        // reverted changeset.
        if (isset($item->variables[$name])) {
          unset($item->variables[$name]);
        }
      }
    }
    cache_clear_all('variables', 'cache_bootstrap');
  }

  $context['message'] = t('Reverting variables');
}

/**
 * Batch API callback to put in changeset markers for items that exist but didn't change.
 * @param $entity_type
 * @param $context
 */
function cps_changeset_unpublish_batch_entity($entity_type, &$context) {
  // Use the $context['sandbox'] at your convenience to store the
  // information needed to track progression between successive calls.
  $entity_info = entity_get_info($entity_type);
  if (empty($context['sandbox'])) {
    $context['sandbox'] = array();
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_item'] = 0;
    $context['message'] = t('Reverting @entity_type content', array('@entity_type' => $entity_info['label']));
  }

  // Ensure that entities are queried and loaded in the published changeset.
  // cps_override_changeset() does not work for EntityFieldQuery() since it only
  // affects the handler.
  cps_set_current_changeset(CPS_PUBLISHED_CHANGESET);
  $count = 0;
  $limit = 100;
  // We should be able to process a lot of these at a time.
  try {
    $query = new EntityFieldQuery();
    $results = $query
      ->entityCondition('entity_type', $entity_type)
      ->range($context['sandbox']['current_item'], $limit)
      ->propertyOrderBy($entity_info['entity keys']['id'], 'DESC')
      ->execute();
    $context['sandbox']['progress']++;
  }
  catch (Exception $e) {
  }

  if (!empty($results[$entity_type])) {
    $count = count($results[$entity_type]);
    $handler = cps_entity_plugin_get_handler($entity_type);
    $handler->cps_revision_reset = TRUE;

    // Load which entities have revisions.
    $result = db_query('SELECT * FROM {cps_entity} WHERE entity_type = :entity_type AND entity_id IN (:entity_id) AND changeset_id = :changeset',
      array(
        ':entity_type' => $entity_type,
        ':entity_id' => array_keys($results[$entity_type]),
        ':changeset' => $context['results']['previous']->changeset_id,
      ));

    $changesets = array();
    while ($record = $result->fetchObject()) {
      $changesets[$record->entity_id] = $record;
    }
    // Loading entities also has to happen in the published changeset.
    // For each entity whose current revision_id is different from the previous, republish the previous.
    foreach (entity_load($entity_type, array_keys($results[$entity_type])) as $entity) {
      // Publishing revisions has to happen in the changeset of the revision
      // being published.
      list($entity_id, $revision_id,) = entity_extract_ids($entity_type, $entity);
      if (isset($changesets[$entity_id]->revision_id) && $revision_id != $changesets[$entity_id]->revision_id) {
        cps_override_changeset($context['results']['previous']->changeset_id);
        $handler->makeChangesetRevisionPublished($entity_id, $context['results']['previous']->changeset_id);
      }
      else {
        // Check to see if there wasn't a revision of the entity in the previous revision
        // at all. If that is the case, the entity was new and there was an initial live
        // revision created for it that exists in no changeset. We'll have to make that
        // revision live again.
        if (!isset($changesets[$entity_id])) {
          cps_override_changeset('initial');
          $handler->makeChangesetRevisionPublished($entity_id, 'initial');
        }

        // If the reverted revision is the same as the live revision, remove the record so
        // we do not falsely report too many changes.
        db_delete('cps_entity')
          ->condition('entity_type', $entity_type)
          ->condition('entity_id', $entity_id)
          ->condition('changeset_id', $context['results']['entity']->changeset_id)
          ->isNotNull('published')
          ->execute();
      }
      cps_override_changeset(CPS_PUBLISHED_CHANGESET);
    }
    $handler->cps_revision_reset = FALSE;
  }

  if ($count < $limit) {
    $context['finished'] = TRUE;
  }
  else {
    $context['finished'] = FALSE;
    $context['sandbox']['current_item'] += $limit;
  }
}

/**
 * Batch API callback to finish the submission.
 *
 * @param $success
 * @param $results
 * @param $operations
 */
function cps_changeset_unpublish_batch_finished($success, $results, $operations) {
  if ($success) {
    // Set the publication time on the item. We have to GET the item somehow.
    $results['entity']->published = NULL;
    $results['entity']->setStatus('unpublished');
    $results['entity']->save();

    drupal_set_message(t('The site version %changeset has been unpublished.', array('%changeset' => $results['entity']->name)));
  }

  module_invoke_all('cps_changeset_published', $results['entity'], 'unpublished');

  cps_publish_unlock();
}

