<?php

/**
 * @file
 * Main module file for the Content Preview System.
 */

define('CPS_PUBLISHED_CHANGESET', 'published');
define('CPS_INSTALLED_CHANGESET', 'installed');

define('CPS_LIVE_STATUS', 'live');
define('CPS_ARCHIVED_STATUS', 'archived');

require_once __DIR__ . '/includes/query.inc';

// -----------------------------------------------------------------------
// Drupal Core Hooks

/**
 * Implements hook_boot().
 */
function cps_boot() {
  // If we are looking at a changeset, load overridden variables and add
  // them into $conf.

  // This isn't using cps_changeset_load() because that loads a bunch of things
  // that don't exist during hook_boot.
  if (variable_get('cps_override_variables', FALSE)) {
    $changeset_id = cps_get_current_changeset();
    if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
      $vars = db_query("SELECT variables FROM {cps_changeset} WHERE changeset_id = :changeset_id", array(':changeset_id' => $changeset_id))->fetchField();
      if ($vars) {
        global $conf;
        global $cps_conf;
        $cps_conf = unserialize($vars);

        if ($cps_conf) {
          foreach ($cps_conf as $name => $value) {
            $conf[$name] = $value;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_exit().
 */
function cps_exit() {
  if (variable_get('cps_override_variables', FALSE)) {
    global $cps_conf_changed;
    if (!empty($cps_conf_changed)) {
      $changeset_id = cps_get_current_changeset(TRUE);
      if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
        $changeset = cps_changeset_load($changeset_id);
        // Only write if $changeset->published is empty.
        if (empty($changeset->published)) {
          global $cps_conf;
          $changeset->variables = $cps_conf;
          $changeset->save();
        }
      }
    }
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function cps_module_implements_alter(&$implementations, $hook) {
  if (in_array($hook, array('entity_query_alter', 'views_query_alter'))) {
    // Move CPS's query alter after entity reference's so we can remove the
    // checks for published status.
    $temp = $implementations['cps'];
    unset($implementations['cps']);
    $implementations['cps'] = $temp;
  }
}

/**
 * Implements of hook_permission()
 */
function cps_permission() {
  return array(
    'administer changesets' => array(
      'title' => t('Administer site versions'),
      'description' => t('Add, delete, edit and manipulate site versions.'),
    ),
    'edit all changesets' => array(
      'title' => t('Edit all site versions'),
      'description' => t('Can edit site versions owned by other people.'),
    ),
    'view changesets' => array(
      'title' => t('View site versions'),
      'description' => t('View the site version widget and change the site preview accordingly.'),
    ),
    'preview changesets' => array(
      'title' => t('Preview site versions'),
      'description' => t('Preview site versions without being able to see the widget.'),
    ),
    'publish changesets' => array(
      'title' => t('Publish site versions'),
      'description' => t('Can publish site versions.'),
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function cps_entity_info() {
  $info = array();

  $info['cps_changeset'] = array(
    'label' => t('Site version'),
    'entity class' => 'CPSChangeset',
    'controller class' => 'CPSChangesetController',
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => 'cps_changeset',
    // After variants this will change to FALSE
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'changeset_id',
      'label' => 'name',
    ),
    'bundles' => array(
      'cps_changeset' => array(
        'label' => t('Site version'),
      ),
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full'),
        'custom settings' => FALSE,
      ),
      'embed' => array(
        'label' => t('Embedded'),
        'custom settings' => FALSE,
      ),
      'mail' => array(
        'label' => t('Mailed'),
        'custom settings' => FALSE,
      ),
    ),
    // entity module callbacks
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'view callback' => 'entity_metadata_view_single',
    'creation callback' => 'cps_changeset_create',
    'access callback' => 'cps_changeset_access',
    'save callback' => 'cps_changeset_save',
    'module' => 'cps',
  );

  return $info;
}

/**
 * Implements hook_menu().
 */
function cps_menu() {
  $items = array();
  $items['admin/structure/changesets/%cps_changeset'] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('cps_changeset', 3),
    'page callback' => 'cps_changeset_view_page',
    'page arguments' => array(3, 'full'),
    'access callback' => 'entity_access',
    'access arguments' => array('view', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/view'] = array(
    'title' => 'Status',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_edit_page',
    'page arguments' => array(3),
    'access callback' => 'entity_access',
    'access arguments' => array('update', 'cps_changeset', 3),
    'weight' => -9,
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/view-site'] = array(
    'title' => 'Switch to this version',
    'type' => MENU_LOCAL_ACTION,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_view_site_page',
    'page arguments' => array(3),
    'access callback' => 'cps_changeset_view_site_access',
    'access arguments' => array(3),
    'file' => 'includes/admin.inc',
    'weight' => -10,
  );

  $items['admin/structure/changesets/%cps_changeset/publish'] = array(
    'title' => 'Publish',
    'type' => MENU_LOCAL_ACTION,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_publish_page',
    'page arguments' => array(3),
    'access callback' => 'entity_access',
    'access arguments' => array('publish', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/unpublish'] = array(
    'title' => 'Unpublish',
    'type' => MENU_LOCAL_ACTION,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_unpublish_page',
    'page arguments' => array(3),
    'access callback' => 'entity_access',
    'access arguments' => array('unpublish', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/delete'] = array(
    'title' => 'Delete',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cps_changeset_delete_form', 3),
    'access callback' => 'entity_access',
    'access arguments' => array('delete', 'cps_changeset', 3),
    'weight' => -8,
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/remove/%/%'] = array(
    'title' => 'Remove',
    'type' => MENU_CALLBACK,
    'page callback' => 'cps_changeset_remove_page',
    'page arguments' => array(3, 5, 6),
    'access callback' => 'entity_access',
    'access arguments' => array('update', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/move/%/%'] = array(
    'title' => 'Move',
    'type' => MENU_CALLBACK,
    'page callback' => 'cps_changeset_move_page',
    'page arguments' => array(3, 5, 6),
    // Handle access checking in the callback as its a bit complex for here.
    'access callback' => TRUE,
    'file' => 'includes/admin.inc',
  );

  if (module_exists('devel')) {
    $items['admin/structure/changesets/%cps_changeset/devel'] = array(
      'title' => 'Devel',
      'page callback' => 'devel_load_object',
      'page arguments' => array('cps_changeset', 3),
      'access arguments' => array('access devel information'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 100,
      'file' => 'devel.pages.inc',
      'file path' => drupal_get_path('module', 'devel'),
    );

    $items['admin/structure/changesets/%cps_changeset/devel/load'] = array(
      'title' => 'Load',
      'type' => MENU_DEFAULT_LOCAL_TASK,
    );

    $items['admin/structure/changesets/%cps_changeset/devel/render'] = array(
      'title' => 'Render',
      'page callback' => 'devel_render_object',
      // Normally this would be the name of the entity type, but slightly
      // modified in order to call the right function.
      'page arguments' => array('cps_changeset', 3),
      'access arguments' => array('access devel information'),
      'file' => 'devel.pages.inc',
      'file path' => drupal_get_path('module', 'devel'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 100,
    );
  }

  $items['admin/structure/changesets'] = array(
    'title' => 'Site versions',
    'description' => 'Manage changesets.',
    'page callback' => 'cps_changeset_list_page',
    'page arguments' => array('administer_changesets'),
    'file' => 'includes/admin.inc',
    'access arguments' => array('administer changesets'),
    'weight' => -10,
  );

  $items['admin/structure/changesets/open'] = array(
    'title' => 'Open',
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/structure/changesets/archived'] = array(
    'title' => 'Archive',
    'page callback' => 'cps_changeset_list_page',
    'page arguments' => array('archived_changesets'),
    'file' => 'includes/admin.inc',
    'access arguments' => array('administer changesets'),
    'weight' => 10,
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/structure/changesets/add'] = array(
    'title' => 'Add site version',
    'page callback' => 'cps_changeset_add_entity_page',
    'page arguments' => array(),
    'access arguments' => array('administer changesets'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/admin.inc',
  );

  return $items;
}

/**
 * Implements hook_entity_load().
 */
function cps_entity_load(&$entities, $entity_type) {
  $entity_info = entity_get_info($entity_type);
  if (empty($entity_info['entity keys']['revision'])) {
    return;
  }
  // When a non-default revision is being loaded, don't overwrite any of the
  // contents of that revision.
  foreach ($entities as $entity) {
    // If a revision was requested, then there is only going to be one entity
    // in the list. We don't touch entity loading when a specific revision was
    // requested.
    // When the new drafty dependency is added, drafty module may not actually
    // be enabled, and this can cause fatal errors on sites that load entities
    // during bootstrap, so check for module existence.
    if (module_exists('drafty') && drafty()->wasRevisionRequested($entity)) {
      return;
    }
  }

  $changeset = cps_get_current_changeset();
  // Fetch entity state information for not published changesets OR the current
  // one. We ignore published changesets because those will accrete over time
  // and are generally irrelevant to our needs.
  $keys = array_keys($entities);

  // @todo: should this include the actual 'published' changeset, that has
  // published = 0 so is included in the query currently.
  $changesets = cps_get_unpublished_changesets();
  if ($changeset != CPS_PUBLISHED_CHANGESET) {
    $changesets[] = $changeset;
  }
  $result = db_query('SELECT * FROM {cps_entity} WHERE entity_type = :entity_type AND entity_id IN (:ids) AND changeset_id IN (:changesets)', array(':entity_type' => $entity_type, ':ids' => $keys, ':changesets' => $changesets));
  foreach ($result as $entity_state) {
    $entities[$entity_state->entity_id]->changeset[$entity_state->changeset_id] = $entity_state;
  }

  // We only care further if the current changeset is not the published one.
  if (!$changeset) {
    return;
  }

  $revision_key = $entity_info['entity keys']['revision'];

  foreach ($entities as $entity) {
    list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);

    // If this entity has a revision set for the current change set,
    // we need to swap it out for the correct revision.
    if (!empty($entity->changeset[$changeset]) && $revision_id != $entity->changeset[$changeset]->revision_id) {

      $swap_revision_id = $entity->changeset[$changeset]->revision_id;
      $draft_revisions = entity_load($entity_type, array($entity_id), array($revision_key => $swap_revision_id));

      // Swap the entity!
      if (!empty($draft_revisions[$entity_id])) {
        $new_entity = $entities[$entity_id] = $draft_revisions[$entity_id];
        $new_entity->changeset = $entity->changeset;
        // Store the current revision ID so we can tell later if we need to put it back.
        $new_entity->published_revision_id = $revision_id;
        $new_entity->published_revision = clone($entity);
        // Tell entity API not to save this as the default revision:
        $new_entity->default_revision = FALSE;
        $entities[$entity_id] = $new_entity;
      }
      else {
        // This state is invalid, and all we can do is remove the changeset from the list.
        unset($entity->changeset[$changeset]);
      }
    }
  }
}

/**
 * Get all unpublished changesets.
 */
function cps_get_unpublished_changesets() {
  $changesets = &drupal_static(__FUNCTION__);
  if (!isset($changesets)) {
    $changesets = db_query('SELECT changeset_id FROM {cps_changeset} WHERE published = 0')->fetchCol();
  }
  return $changesets;
}

/**
 * Implements hook_entity_presave().
 */
function cps_entity_presave($entity, $entity_type) {
  if (cps_is_supported($entity_type)) {
    $initial = FALSE;
    $current_changeset = cps_get_current_changeset();
    if (!empty($entity->cps_initial_unpublished)) {
      $initial = TRUE;
      cps_override_changeset('initial');
    }
    else if ($current_changeset != CPS_PUBLISHED_CHANGESET) {
      list($id) = entity_extract_ids($entity_type, $entity);
      // Force a draft revision to be created when updating entities within a
      // changeset. However respect the state of $entity->is_draft_revision if
      // it is already set since drafty uses this internally to re-save the
      // published version, and other modules may need the ability to override
      // this in specific circumstances.
      if (isset($id) && !isset($entity->is_draft_revision)) {
        $entity->is_draft_revision = TRUE;
      }
    }

    cps_set_revision_log($entity);

    if ($initial) {
      // Ordinarily we should use NULL to reset the override, but
      // we may have already been overridden when we got here so just
      // put back what we found instead.
      cps_override_changeset($current_changeset);
    }
  }
}

/**
 * Implements hook_entity_insert().
 */
function cps_entity_insert($entity, $entity_type) {
  if (!cps_is_supported($entity_type)) {
    return;
  }

  $changeset = cps_get_current_changeset();
  list($entity_id, $revision_id) = entity_extract_ids($entity_type, $entity);

  // If a new entity is inserted with the live/published changeset active,
  // it is immediately live. Mark it as such in the most recently published
  // changeset. This handles making sure that there is a history for
  // programmatically created entities outside of changesets.
  if ($changeset == CPS_PUBLISHED_CHANGESET) {
    $changeset_id = db_query("SELECT changeset_id FROM {cps_changeset} ORDER BY published DESC LIMIT 1")->fetchCol();
    db_insert('cps_entity')
      ->fields(array(
        'entity_type' => $entity_type,
        'entity_id' => $entity_id,
        'revision_id' => $revision_id,
        'changeset_id' => $changeset_id,
        'published' => TRUE,
      ))->execute();

    return;
  }

  // When an new entity is inserted, we actually want two revisions to be saved.
  //  - An unpublished revision in the 'published' changeset, since CPS treats
  //    any entity that's never been published as 'unpublished'.
  //  - A draft revision in the current changeset with the published flag set to
  //    the same as on the node form.

  db_insert('cps_entity')
    ->fields(array(
      'entity_type' => $entity_type,
      'entity_id' => $entity_id,
      'changeset_id' => $changeset,
      'revision_id' => $revision_id,
   ))->execute();
  // Operate on a clone to avoid changing the entity prior to subsequent
  // hook_entity_insert() implementations.
  $live_revision = clone $entity;

  // The entity is no longer new.
  unset($live_revision->is_new);

  entity_status_set($entity_type, $live_revision, ENTITY_UNPUBLISHED);

  $live_revision->cps_initial_unpublished = TRUE;
  module_invoke_all('cps_live_revision_create', $entity_type, $live_revision);
  entity_save($entity_type, $live_revision);
}

/**
 * Implements hook_entity_update().
 */
function cps_entity_update($entity, $entity_type) {
  $changeset = cps_get_current_changeset();
  // If we are not on a change set, do nothing.
  if ($changeset == CPS_PUBLISHED_CHANGESET || !cps_is_supported($entity_type)) {
    return;
  }

  // @see cps_entity_insert().
  if (!empty($entity->cps_initial_unpublished)) {
    $changeset = 'initial';
  }

  // Only the 'initial' revision and draft revisions should be tracked in
  // changesets. Everything else is in the 'published' changeset which is
  // untracked.
  if ($changeset !== 'initial' && !drafty()->isDraftRevision($entity)) {
    return;
  }

  list($entity_id, $revision_id) = entity_extract_ids($entity_type, $entity);
  // Store state information.
  db_merge('cps_entity')
    ->key(array(
      'entity_type' => $entity_type,
      'entity_id' => $entity_id,
      'changeset_id' => $changeset,
    ))
    ->fields(array(
      'revision_id' => $revision_id,
    ))
    ->execute();
}

/**
 * Implements hook_entity_delete().
 */
function cps_entity_delete($entity, $entity_type) {
  list($entity_id) = entity_extract_ids($entity_type, $entity);
  db_delete('cps_entity')
    ->condition('entity_type', $entity_type)
    ->condition('entity_id', $entity_id)
    ->execute();
}

/**
 * Implements hook_field_attach_delete_revision().
 */
function cps_field_attach_delete_revision($entity_type, $entity) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);
  db_delete('cps_entity')
    ->condition('entity_type', $entity_type)
    ->condition('revision_id', $revision_id)
    ->condition('entity_id', $entity_id)
    ->execute();
}

function cps_form_views_exposed_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form_state['view']) && ($form_state['view']->tag == 'cps' || $form_state['view']->tag == 'only mine') && isset($form['uid_current'])) {
    $form['uid_current']['#options'] = array(
      'All' => t('All'),
      '1' => t('Only mine'),
    );
  }
}

// -----------------------------------------------------------------------
// Contrib Hooks

/**
 * Implements hook_ctools_plugin_directory().
 */
function cps_ctools_plugin_directory($module, $plugin) {
  if ($module == 'cps') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_iib_page_item().
 */
function cps_iib_page_item() {
  if (user_access('view changesets')) {
    $path = drupal_get_path('module', 'cps');
    ctools_include('forms', 'cps');
    $items['left'] = array(
      '#weight' => -10,
      'form' => drupal_get_form('cps_changeset_preview_form'),
      '#attached' => array(
        'css' => array("$path/css/cps.css"),
        'js' => array(
          "$path/js/cps.js",
          array(
            'data' => array(
              'cps' => array('changeset_id' => cps_get_current_changeset(TRUE)),
            ),
            'type' => 'setting',
          ),
        ),
      ),
    );
    return $items;
  }
}

/**
 * Implements hook_iib_hidden_alter().
 */
function cps_iib_hidden_alter(&$hidden) {
  $hidden = FALSE;
}

/**
 * Implements hook_ctools_plugin_api().
 */
function cps_ctools_plugin_api($module, $api) {
  if ($module == 'cps' && $api == 'cps') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_views_api().
 */
function cps_views_api() {
  return array(
    'path' => drupal_get_path('module', 'cps') . '/plugins/views',
    'api' => 3,
  );
}

/**
 * Sets the revision log for an entity.
 */
function cps_set_revision_log($entity) {
  $current_changeset = cps_get_current_changeset();
  if ($current_changeset != CPS_PUBLISHED_CHANGESET) {
    $changeset = cps_changeset_load($current_changeset);
    if ($changeset) {
      $name = $changeset->name;
    }
    else {
      $name = $current_changeset;
    }
  }
  else {
    $name = 'Published';
  }
  $entity->log = t('Revision for site version @changeset', array('@changeset' => $name));
}

/**
 * Implements hook_entity_property_info().
 */
function cps_entity_property_info() {
  return entity_get_controller('cps_changeset')->hook_entity_property_info();
}

/**
 * Implements hook_entitycache_load_alter().
 */
function cps_entitycache_load_alter(&$entities) {
  if (cps_get_current_changeset() !== CPS_PUBLISHED_CHANGESET) {
    // If the state is not empty, do not let entitycache load things from cache.
    $entities = array();
  }
}

/**
 * Implements hook_entitycache_save_alter().
 */
function cps_entitycache_save_alter(&$entities) {
  if (cps_get_current_changeset() !== CPS_PUBLISHED_CHANGESET) {
    // If the state is not empty, do not let entitycache save things in cache.
    $entities = array();
  }
}

// -----------------------------------------------------------------------
// Public API

/**
 * Fetch the currently in use changeset.
 *
 * @param $test
 *   If TRUE, test to ensure the changeset is valid.
 *
 * @return string
 *   The current changeset id.
 */
function cps_get_current_changeset($test = FALSE) {

  if (isset($GLOBALS['cps_override_changeset'])) {
    return $GLOBALS['cps_override_changeset'];
  }
  if (!function_exists('user_access')) {
    drupal_load('module', 'user');
  }

  if (!drupal_is_cli() && !user_access('preview changesets') && !user_access('view changesets') && !user_access('administer changesets')) {
    return CPS_PUBLISHED_CHANGESET;
  }

  if (isset($_GET['changeset_id'])) {
    $changeset_id = $_GET['changeset_id'];
    $_SESSION['changeset_id'] = $changeset_id;
  }
  elseif (isset($_SESSION['changeset_id'])) {
    $changeset_id = $_SESSION['changeset_id'];
  }
  else {
    $changeset_id = CPS_PUBLISHED_CHANGESET;
  }

  // Use a $test flag because there are phases where we do not want to invoke
  // a load.
  if ($test && $changeset_id != CPS_PUBLISHED_CHANGESET) {
    $changeset = cps_changeset_load($changeset_id);

    if (!$changeset) {
      // If no changeset was loaded, default to published.
      $changeset_id = CPS_PUBLISHED_CHANGESET;
    }
  }

  if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
    // Record that we have touched this changeset.
    $_SESSION['touched changesets'][$changeset_id] = REQUEST_TIME;
  }

  return $changeset_id;
}

/**
 * Set the current changeset.
 *
 * @param string $changeset_id
 *   The changeset id.
 */
function cps_set_current_changeset($changeset_id) {
  if (isset($changeset_id)) {
    $_SESSION['changeset_id'] = $changeset_id;
  }
  elseif (isset($_SESSION['changeset_id'])) {
    unset($_SESSION['changeset_id']);
  }
}

/**
 * Set a global override for the current changeset.
 *
 * @param $changeset_id
 */
function cps_override_changeset($changeset_id) {
  global $cps_override_changeset;
  $cps_override_changeset = $changeset_id;

  // We have to reset the entity static cache because changing this could poison
  // the cache.
  foreach (entity_get_info() as $entity_type => $entity_info) {
    if (cps_is_supported($entity_type)) {
      entity_get_controller($entity_type)->resetCache();
    }
  }
}

/**
 * Check whether CPS is supported for an entit type.
 *
 * @param string $entity_type
 */
function cps_is_supported($entity_type) {
  $info = entity_get_info($entity_type);
  return !empty($info['cps']);
}

/**
 * Get supported entity types.
 */
function cps_get_supported() {
  $types = array();
  $info = entity_get_info();
  foreach ($info as $entity_type => $entity_info) {
    if (!empty($entity_info['cps'])) {
      $types[] =  $entity_type;
    }
  }
  return $types;
}

/**
 * @{inheritdoc}
 */
function cps_make_revision_published($entity_type, $entity_id, $changeset_id) {
  cps_override_changeset(CPS_PUBLISHED_CHANGESET);
  // Find the revision id.
  $revision_id = db_query('SELECT revision_id FROM {cps_entity} WHERE entity_type = :entity_type AND entity_id = :entity_id AND changeset_id = :changeset',
  array(
    ':entity_type' => $entity_type,
    ':entity_id' => $entity_id,
    ':changeset' => $changeset_id,
  ))->fetchField();

  drafty()->publishRevision($entity_type, $entity_id, $revision_id);
  cps_override_changeset(NULL);
}

/**
 * Get tracked entities in a changeset.
 *
 * @param $changeset_id
 *   A changeset ID.
 *
 * @return
 *   An array with entity type as keys and array of entity IDs as values.
 *   type.
 */
function cps_get_tracked_entities($changeset_id) {
  $cache = &drupal_static(__FUNCTION__, array());
  if (!isset($cache[$changeset_id])) {
    $result = db_query('SELECT entity_type, entity_id  FROM {cps_entity} WHERE changeset_id = :changeset_id AND published = 0', array(':changeset_id' => $changeset_id));
    foreach ($result as $record) {
      $cache[$changeset_id][$record->entity_type][$record->entity_id] = $record->entity_id;
    }
  }
  return $cache[$changeset_id];
}

/**
 * Publish a changeset.
 *
 * @param $changeset_id
 *   A changeset ID.
 */
function cps_publish_changeset_entities($changeset_id) {
  // Get all tracked entities in the changeset.
  $changed = cps_get_tracked_entities($changeset_id);
  $transaction = db_transaction();
  try {
    foreach ($changed as $entity_type => $entity_ids) {
      foreach ($entity_ids as $entity_id) {
        cps_make_revision_published($entity_type, $entity_id, $changeset_id);
      }
    }
  }
  catch (Exception $e) {
    $transaction->rollback();
    trigger_error(t('Unable to publish entities in changeset'), E_USER_ERROR);
    watchdog_exception('CPS', $e);
  }
}

/**
 * Unpublish a changeset.
 *
 * @param $changeset_id
 *   A changeset ID.
 */
function cps_unpublish_changeset_entities($changeset_id, $previous_changeset_id) {
  $changed = cps_get_tracked_entities($changeset_id);
  $transaction = db_transaction();
  try {
    foreach ($changed as $entity_type => $entity_ids) {
      foreach ($entity_ids as $entity_id) {
        $vid = db_query('SELECT revision_id FROM {cps_entity} WHERE entity_type = :entity_type AND entity_id = :entity_id AND changeset_id = :changeset_id AND published = 0', array(
          'entity_type' => $entity_type,
          'entity_id' => $entity_id,
          'changeset_id' => $changeset_id,
        ))->fetchField();
        if ($vid) {
          cps_make_revision_published($entity_type, $entity_id, $previous_changeset_id);
        }
        else {
          cps_make_revision_published($entity_type, $entity_id, 'initial');
        }
      }
    }
  }
  catch (Exception $e) {
    $transaction->rollback();
    trigger_error(t('Unable to unpublish entities in changeset'), E_USER_ERROR);
    watchdog_exception('CPS', $e);
  }
}

/**
 * Remove non-tracked items from a changeset.
 *
 * @param $changeset_id
 *   A changeset ID.
 */
function cps_remove_untracked_entities($changeset_id) {
  db_delete('cps_entity')
    ->condition('changeset_id', $changeset_id)
    ->condition('published', 1)
    ->execute();
}

/**
 * Record the published version ID for untracked entities.
 *
 * @param $changeset_id
 *   The changeset ID.
 * @param $entity_type
 *   Then entity type.
 * @param $start
 *   The entity ID to start the query from, defaults to 0.
 * @param $limit
 *   The number of entities to process.
 */
function cps_add_untracked_entities($changeset_id, $entity_type, $start = 0, $limit = 100) {

  // Ensure the EntityFieldQuery here does not get altered.
  cps_override_changeset(CPS_PUBLISHED_CHANGESET);
  $tracked = cps_get_tracked_entities($changeset_id);
  $info = entity_get_info($entity_type);

  $entity_query = new EntityFieldQuery();
  if (!empty($tracked[$entity_type])) {
    $entity_query->entityCondition('entity_id', $tracked[$entity_type], 'NOT IN');
  }
  $results = $entity_query
    ->entityCondition('entity_type', $entity_type)
    ->entityOrderBy('entity_id', 'ASC')
    ->range($start, $limit)
    ->execute();

  // Reset the changeset
  cps_override_changeset(NULL);
  if (!empty($results[$entity_type])) {
    $query = db_insert('cps_entity')
      ->fields(array(
        'entity_type',
        'entity_id',
        'revision_id',
        'changeset_id',
        'published',
      ));
    foreach ($results[$entity_type] as $entity) {
      $query->values(array(
        'entity_type' => $entity_type,
        'entity_id' => $entity->{$info['entity keys']['id']},
        'revision_id' => $entity->{$info['entity keys']['revision']},
        'changeset_id' => $changeset_id,
        'published' => 1,
      ));
    }
    $query->execute();
    // Return the count of entities that were updated.
    return min($limit, count($results[$entity_type]));
  }
}

/**
 * Determine if entity editing is allowable.
 *
 * We disallow the editing or creation of entities and anything else managed by
 * changesets when viewing the published changeset (i.e, the live site) or when
 * viewing a previously published changeset (i.e, an archive view).
 *
 * @param $op
 *   The operation to check. Any $op which isn't view' is considered an edit,
 *   so non-privileged non-view operations should be filtered by the caller.
 * @param string $entity_type
 *   The type of entity to test.
 * @param $entity
 *   The entity to check.
 * @param $changeset_id
 *   The changeset to check against. If not specified the currently active changeset
 *   will be used.
 *
 * @return bool
 */
function cps_can_edit_entities($op, $entity_type, $entity, $changeset_id = NULL) {
  // Deletions can occur outside of a changeset if the content was never published.
  if ($op == 'delete') {
    return cps_can_delete_entity($entity_type, $entity);
  }

  if (!isset($changeset_id)) {
    $changeset_id = cps_get_current_changeset(TRUE);
  }

  if ($op == 'view') {
    if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
      return TRUE;
    }

    if (entity_status_supported($entity_type)) {
      return entity_status_get($entity_type, $entity);
    }
    else {
      return TRUE;
    }
  }

  // The live changeset can never be edited for any reason, and we just bounce
  // it out early, without even letting other modules get involved.
  if ($changeset_id == CPS_PUBLISHED_CHANGESET) {
    return FALSE;
  }

  $changeset = cps_changeset_load($changeset_id);

  // Only unpublished changesets allow editing.
  $access = $changeset->status == 'unpublished';

  // Unless the user has edit all changesets, they can only make changes in
  // their own.
  if (!user_access('edit all changesets') && $GLOBALS['user']->uid != $changeset->uid) {
    $access = FALSE;
  }

  // If $op == 'move to' they cannot make this change if the entity already has
  // a revision in the changeset.
  if ($op == 'move to') {
    if ($entity && !empty($entity->changeset[$changeset_id])) {
      $access = FALSE;
    }
  }

  // Allow other modules to change this if needed.
  $context = array(
    'op' => $op,
    'entity_type' => $entity_type,
    'entity' => $entity,
    'changeset' => $changeset,
  );
  drupal_alter('cps_can_edit_entities', $access, $context);
  return $access;
}

/**
 * Determine if an entity can be deleted.
 *
 * Once an entity has appeared in a published changeset, the entity should
 * not be deletable so that the site history is preserved. Instead, entities
 * should be unpublished which will make them disappear from standard view.
 *
 * This method ONLY checks for CPS reasons, and the entity is expected
 * to do its own access control.
 *
 * @param string $entity_type
 *   The type of entity to test.
 * @param $entity
 *   The entity to check.
 * @return bool
 *   TRUE if the entity can be deleted, FALSE if not.
 */
function cps_can_delete_entity($entity_type, $entity) {
  list($entity_id) = entity_extract_ids($entity_type, $entity);

  // Fetch a list of revisions directly joining to the cps table to find
  // revisions that point to published changesets.
  $entity_info = entity_get_info($entity_type);
  $revision_table = $entity_info['revision table'];
  $id_field = $entity_info['entity keys']['id'];
  $revision_field = $entity_info['entity keys']['revision'];

  $result = db_query("SELECT DISTINCT base.$revision_field FROM " . "{" . $revision_table . "} base LEFT JOIN {cps_entity} c ON base.$id_field = c.entity_id AND base.$revision_field = c.revision_id AND c.entity_type = '$entity_type' LEFT JOIN {cps_changeset} cs ON cs.changeset_id = c.changeset_id WHERE base.$id_field = :entity_id AND cs.published <> 0", array(':entity_id' => $entity_id))->fetchCol();

  if (!$result) {
    return TRUE;
  }

  if (!entity_status_supported($entity_type)) {
    return FALSE;
  }

  // If we do have a result, go through each revision and see if any are published. If any are,
  // deny.
  foreach ($result as $revision_id) {
    $revision = entity_revision_load($entity_type, $revision_id);
    if ($revision && entity_status_get($entity_type, $revision)) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Gets the available changesets for the widget.
 *
 * @return string[]
 *   The list of available changesets, keyed by ID.
 */
function cps_get_changesets() {
  global $user;
  try {
    $query = new EntityFieldQuery();
    $results = $query->entityCondition('entity_type', 'cps_changeset')
      ->propertyCondition('status', CPS_ARCHIVED_STATUS, '<>')
      ->propertyCondition('uid', $user->uid)
      ->propertyOrderBy('name')
      // This tag allows another module to modify this list if necessary.
      ->addTag('cps_active_changeset_list')
      ->execute();
  }
  catch (Exception $e) {
    return array();
  }

  $changesets = array();
  if (!empty($results['cps_changeset'])) {
    $entities = cps_changeset_load_multiple(array_keys($results['cps_changeset']));
    foreach ($entities as $id => $entity) {
      $changesets[$id] = $entity->name;
    }
  }

  $published = array(
    0 => t('Live'),
  );

  $recent = array();
  $my_published = array();
  // Go through any changesets they have viewed within the last 24 hours
  // and create a list of them.
  if (!empty($_SESSION['touched changesets'])) {
    $recent_ids = array();
    foreach ($_SESSION['touched changesets'] as $id => $timestamp) {
      if ($timestamp + variable_get('cps_recent_changeset_max_age', 86400) < REQUEST_TIME) {
        unset($_SESSION['touched changesets'][$id]);
      }
      elseif (empty($changesets[$id])) {
        $recent_ids[] = $id;
      }
    }

    if ($recent_ids) {
      $entities = cps_changeset_load_multiple($recent_ids);
      $uids = array();
      foreach ($entities as $entity) {
        $uids[] = $entity->uid;
      }

      $accounts = user_load_multiple($uids);
      foreach ($entities as $id => $entity) {
        if ($entity->uid == $user->uid) {
          $my_published[$id] = $entity->name;
        }
        else {
          $recent[format_username($accounts[$entity->uid])][$id] = $entity->name;
        }
      }
    }
  }

  // Live changeset is always on top.
  $retval = $published;

  // Now my open changesets.
  if ($changesets) {
    $retval += array(t('My open site versions') => $changesets);
  }

  // My published if I've looked at them recently.
  if ($my_published) {
    $retval += array(t('My published') => $my_published);
  }

  // And other people's changesets if I've been looking at them.
  if ($recent) {
    asort($recent);
    $retval += $recent;
  }

  return $retval;
}

/**
 * Fetch a list of possible state types for changesets.
 *
 * @return string[]
 *   An array of state types named keyed by the internal name.
 */
function cps_changeset_get_state_types() {
  $types = &drupal_static(__FUNCTION__);
  if (!isset($types)) {
    $types = array(
      'open' => t('Open'),
      'closed' => t('Closed'),
    );

    drupal_alter('cps_changeset_state_types', $types);
  }


  return $types;
}

/**
 * Fetch a list of possible states for changesets.
 *
 * @return array[]
 *   An array of state named keyed by the internal name.
 */
function cps_changeset_get_states() {
  $states = &drupal_static(__FUNCTION__);
  if (!isset($states)) {
    $states = array(
      'unpublished' => array(
        'label' => t('Unpublished'),
        'weight' => 0,
        'type' => 'open',
      ),
      CPS_ARCHIVED_STATUS => array(
        'label' => t('Archived'),
        'weight' => 9,
        'type' => 'closed',
      ),
    );
    drupal_alter('cps_changeset_states', $states);

    uasort($states, 'drupal_sort_weight');
  }

  return $states;
}

/**
 * Fetch the labels for all changeset states.
 *
 * @return string[]
 */
function cps_changeset_get_state_labels() {
  $labels = &drupal_static(__FUNCTION__);
  if (!$labels) {
    $states = cps_changeset_get_states();

    $labels = array();
    foreach ($states as $state => $info) {
      $labels[$state] = $info['label'];
    }
  }

  return $labels;
}

/**
 * Page callback to render a revisions page.
 *
 * This can be added via hook_menu by any module implementing CPS support
 * for an entity to override the revisions page and show a CPS friendly
 * version of it.
 *
 * @param string $entity_type
 *   The entity type of the entity.
 * @param object $entity
 *   The entity to display revisions for.
 *
 * @return array
 *   A Drupal renderable array of the page.
 */
function cps_show_revisions_page($entity_type, $entity) {
  // @todo: no real need for a wrapper here.
  if (cps_is_supported($entity_type)) {
    require_once __DIR__ . '/includes/admin.inc';
    return cps_revisions_page($entity, $entity_type);
  }

  return array();
}

/**
 * Provide a warning message if the entity has unpublished changes in another changeset.
 *
 * @param object $entity
 *   The entity to test.
 *
 * @return string|null
 *   A warning string or null.
 */
function cps_changeset_edit_warning($entity) {
  // $entity->changeset will only contain unpublished revisions.
  if (empty($entity->changeset)) {
    return;
  }

  foreach (array_keys($entity->changeset) as $id) {
    // Ignore the current changeset.
    if ($id == cps_get_current_changeset()) {
      continue;
    }

    // If anything else pops, put up a warning.
    return t('Warning, this content has unpublished changes in another site version! Whichever site version is published LAST will overwrite the other. Please see the History tab for details to help coordinate your changes.');
  }
}

/**
 * Determine whether an entity is in any published changeset.
 */
function cps_entity_in_published_changeset($entity_type, $entity) {
  list($id) = entity_extract_ids($entity_type, $entity);
  // Treat a changeset as published if the status is 'live' or 'archived'.
  $result = db_query('SELECT 1 FROM {cps_entity} ce INNER JOIN {cps_changeset} cc ON ce.changeset_id = cc.changeset_id AND cc.status IN (:published) WHERE ce.entity_type = :type AND ce.entity_id = :id', array(':published' => array(CPS_ARCHIVED_STATUS, 'published'), ':type' => $entity_type, ':id' => $id))->fetchField();

  return $result;
}


/**
 * Creates an array of rows which represent the difference between nodes.
 *
 * This function relies on the diff module. It is largely copied from
 * _diff_body_rows() which is unnecessarily node specific.
 *
 * @param string $entity_type
 *   The entity type to compare.
 * @param object $old
 *   Node for comparison which will be displayed on the left side.
 * @param object $new
 *   Node for comparison which will be displayed on the right side.
 * @param string $state
 *   The state to render for the diff.
 *
 * @return array
 *   The rows of the diff.
 */
function cps_diff($entity_type, $old, $new, $state = 'raw') {
  if (!module_exists('diff')) {
    return FALSE;
  }

  // This is an unique index only, so no need for drupal_static().
  static $table_row_counter = 0;

  if ($theme = variable_get('diff_theme', 'default')) {
    drupal_add_css(drupal_get_path('module', 'diff') . "/css/diff.{$theme}.css");
  }
  module_load_include('inc', 'diff', 'diff.pages');

  $rows = array();
  $any_visible_change = FALSE;

  // Some special handling if the old version is the special unpublished
  // live revision.

  $is_new = !cps_entity_in_published_changeset($entity_type, $old);

  if (!$is_new) {
    $context = array(
      'entity_type' => $entity_type,
      'states' => array($state),
      'view_mode' => 'diff_standard',
    );

    $diffs = diff_compare_entities($old, $new, $context);

    // Track line numbers between multiple diffs.
    $line_stats = array(
      'counter' => array('x' => 0, 'y' => 0),
      'offset' => array('x' => 0, 'y' => 0),
    );

    // Render diffs for each.
    foreach ($diffs as $diff) {
      $show_header = !empty($diff['#name']);
      // These are field level settings.
      if ($show_header && isset($diff['#settings']['show_header'])) {
        $show_header = $show_header && $diff['#settings']['show_header'];
      }

      // Line counting and line header options.
      if (empty($diff['#settings']['line_counter'])) {
        $line_counter = FALSE;
      }
      else {
        $line_counter = $diff['#settings']['line_counter'];
      }
      // Every call to 'line' resets the counters.
      if ($line_counter) {
        $line_stats['counter']['x'] = 0;
        $line_stats['counter']['y'] = 0;
        if ($line_counter == 'line' && 0) {
          $line_stats['offset']['x'] = 0;
          $line_stats['offset']['y'] = 0;
        }
        $line_stats_ref = $line_stats;
      }
      else {
        $line_stats_ref = NULL;
      }

      list($old_content, $new_content) = diff_extract_state($diff, $state);
      if ($diff_rows = diff_get_rows($old_content, $new_content, $line_counter && $line_counter != 'hidden', $line_stats_ref)) {
        if ($line_counter && $line_counter != 'line') {
          $line_stats['offset']['x'] += $line_stats_ref['counter']['x'];
          $line_stats['offset']['y'] += $line_stats_ref['counter']['y'];
        }
        if ($show_header) {
          $rows['diff-header-' . $table_row_counter++] = array(
            array(
              'data' => t('Changes to %name', array('%name' => $diff['#name'])),
              'class' => 'diff-section-title',
              'colspan' => 4,
            ),
          );
        }
        // To avoid passing counter to the Diff engine, index rows manually here
        // to allow modules to interact with the table. i.e. no array_merge().
        foreach ($diff_rows as $row) {
          $rows['diff-row-' . $table_row_counter++] = $row;
        }
        $any_visible_change = TRUE;
      }
    }
  }

  if (!$any_visible_change) {
    $rows['diff-empty-' . $table_row_counter++] = array(
      array(
        'data' => !$is_new ? t('No visible changes') : t('Newly created'),
        'class' => 'diff-section-title',
        'colspan' => 4,
      ),
    );
    // @todo: revise this.
    // Needed to keep safari happy.
    $rows['diff-empty-' . $table_row_counter++] = array(
      array('data' => ''),
      array('data' => ''),
      array('data' => ''),
      array('data' => ''),
    );
  }

  return $rows;
}

/**
 * Render a diff between two entities of the same type.
 *
 * @param string $entity_type
 *   The entity type to compare.
 * @param object $old
 *   Node for comparison which will be displayed on the left side.
 * @param object $new
 *   Node for comparison which will be displayed on the right side.
 * @param string $state
 *   The state to render for the diff.
 *
 * @return array
 *   An array suitable for drupal_render().
 */
function cps_render_diff($entity_type, $old, $new, $state = 'raw') {
  if (!module_exists('diff')) {
    return array();
  }

  // cps_diff can be long if there's a LOT of content, so let's add some time.
  drupal_set_time_limit(30);
  $rows = cps_diff($entity_type, $old, $new, $state);
  $header = array();

  $build = array(
    '#theme' => 'table__diff__standard',
    '#header' => $header,
    '#rows' => $rows,
    '#attributes' => array('class' => array('diff')),
    '#colgroups' => _diff_default_cols(),
    '#sticky' => FALSE,
    '#changes' => 0,
  );

  foreach ($rows as $key => $row) {
    if (strpos($key, 'diff-row-') === 0) {
      // The Diff module sometimes adds empty rows which are keyed like a
      // change, but are not. Discount these.
      // Rows representing an actual visible change should always have a '+'
      // (which precedes the new content), a '-' (which precedes the removed
      // content) or both. See DrupalDiffFormatter::addedLine() and
      // DrupalDiffFormatter::deletedLine().
      $empty_row = TRUE;
      if (is_array($row)) {
        foreach ($row as $element) {
          if (is_array($element) && isset($element['data']) && in_array($element['data'], array('+', '-'))) {
            $empty_row = FALSE;
            break;
          }
        }
      }
      if (!$empty_row) {
        $build['#changes']++;
      }
    }
  }

  return $build;
}

/**
 * Render a change into a changeset's entity view.
 *
 * @param string $entity_type
 *   The type of entity being rendered.
 * @param object $change
 *   The changed entity being rendered.
 * @param CPSChangeset $entity
 *   The changeset this is for.
 * @return array
 *   An array suitable for drupal_render().
 */
function cps_render_changed_entity($entity_type, $change, $entity) {
  list($entity_id, , $bundle) = entity_extract_ids($entity_type, $change);
  $uri = entity_uri($entity_type, $change);
  $changeset_uri = $entity->uri();

  // Don't render diff for published changesets:
  if (!$entity->published) {
    // We can't actually trust $change->published_revision because it might have
    // loaded incompletely, so let's load a fresh version.

    // Make sure that CPS doesn't swap out the entity it loads!
    cps_override_changeset(CPS_PUBLISHED_CHANGESET);
    $original = entity_load_single($entity_type, $entity_id);
    cps_override_changeset(NULL);

    if (cps_entity_in_published_changeset($entity_type, $original)) {
      $diff = cps_render_diff($entity_type, $original, $change);
      if (!empty($diff['#changes'])) {
        $title = format_plural($diff['#changes'], '1 change', '@count changes');
      }
      else {
        // If there are no changes, we should get either new entity or no visible changes.
        if ($diff) {
          $title = reset($diff['#rows']);
          $title = $title[0]['data'];
        }
        else {
          $title = t('No visible changes');
        }
      }
    }
    else {
      $diff = array();
      $title = t('Newly created');
    }
  }
  else {
    $diff = array();
    $title = t('No diffs for published site versions');
  }

  $can_edit = cps_can_edit_entities('update', $entity_type, $change, $entity->changeset_id);

  $entity_info = entity_get_info($entity_type);
  $build = array(
    '#entity' => $change,
    'top' => array(
      '#prefix' => '<tr class="even">',
      'title' => array(
        '#prefix' => '<td class="cps-title">',
        '#markup' => check_plain(entity_label($entity_type, $change)),
        '#suffix' => '</td>',
      ),
      'bundle' => array(
        '#prefix' => '<td class="cps-bundle">',
        '#markup' => $entity_info['bundles'][$bundle]['label'],
        '#suffix' => '</td>',
      ),
      'operations' => array(
        '#prefix' => '<td class="cps-operations">',
        'view' => array(
          '#theme' => 'link',
          '#text' => t('view'),
          '#path' => $uri['path'],
          '#options' => array(
            'query' => array('changeset_id' => $entity->changeset_id),
            'html' => TRUE,
            'attributes' => array('class' => array('cps-changeset-operation')),
          ),
        ),
        'remove' => array(
          '#theme' => 'link',
          '#text' => t('remove from site version'),
          '#path' => $changeset_uri['path'] . '/remove/' . $entity_type . '/' . $entity_id,
          '#options' => array(
            'query' => drupal_get_destination(),
            'html' => TRUE,
            'attributes' => array('class' => array('cps-changeset-operation')),
          ),
          '#access' => $can_edit,
        ),
        'move' => array(
          '#theme' => 'link',
          '#text' => $can_edit ? t('move/copy to current site version') : t('copy to current site version'),
          '#path' => $changeset_uri['path'] . '/move/' . $entity_type . '/' . $entity_id,
          '#options' => array(
            'query' => drupal_get_destination(),
            'html' => TRUE,
            'attributes' => array('class' => array('cps-changeset-operation')),
          ),
          '#access' => cps_can_edit_entities('move to', $entity_type, $change) && $entity->changeset_id != cps_get_current_changeset(),
        ),
        '#suffix' => '</td>',
      ),
      '#suffix' => '</tr>',
    ),
    'bottom' => array(
      '#prefix' => '<tr class="odd"><td colspan="3" class="cps-changes"><div class="ctools-collapsible-container ctools-collapsed">',
      'title' => array(
        '#prefix' => '<div class="ctools-collapsible-handle">',
        '#markup' => $title,
        '#suffix' => '</div>',
      ),
      'changes' => array(
        '#prefix' => '<div class="ctools-collapsible-content">',
        'diff' => $diff,
        '#suffix' => '</div>',
      ),
      '#suffix' => '</div></td></tr>',
    ),
    '#suffix' => '</div>',
  );

  return $build;
}

/**
 * Lock the CPS publishing system.
 *
 * @return bool
 *   TRUE if the lock can be acquired. FALSE if not.
 *
 * @see cps_publish_lock_time()
 */
function cps_publish_lock() {
  $time = cps_publish_lock_time();
  if ($time) {
    return FALSE;
  }
  // Set the lock to expire in 30 minutes.
  // This seems like a long time, but some publishing runs can be quite long, and we want
  // to make sure they finish and that a timeout truly represents an aborted publishing job,
  // for example because the user navigated away from the batch job before it completed.
  // Because this is intended to be used in batch processes (for which the lock needs to be
  // held for more than one page request, until the batch job is complete) it cannot use the
  // core lock API. Therefore it uses a variable instead.
  variable_set('cps_publishing_lock', REQUEST_TIME + variable_get('cps_publishing_lock_expire', 60 * 30));
  return TRUE;
}

/**
 * Unlock the CPS publishing system.
 */
function cps_publish_unlock() {
  variable_del('cps_publishing_lock');
}

/**
 * Test the CPS publishing lock.
 *
 * @return int
 *   The number of seconds remaining if publishing is locked, FALSE if it is not.
 */
function cps_publish_lock_time() {
  $lock = variable_get('cps_publishing_lock', 0);
  if ($lock > REQUEST_TIME) {
    return $lock - REQUEST_TIME;
  }

  return FALSE;
}

// -------------------------------------------------------------------------
// Database and general entity API functions

/**
 * Changeset entity loader.
 *
 * @param string $changeset_id
 *   The changeset id.
 *
 * @return CPSChangeset
 *   The changeset, if found.
 *
 * @see entity_load()
 */
function cps_changeset_load($changeset_id) {
  $entities = cps_changeset_load_multiple(array($changeset_id));
  if ($entities) {
    return reset($entities);
  }
}

/**
 * Load multiple changesets.
 *
 * @param string[] $ids
 *   An array of IDs to load.
 * @param array $conditions
 *   (optional) An array of conditions.
 * @param bool $reset
 *   (optional) TRUE to force a load from database.
 *
 * @see entity_load_multiple()
 */
function cps_changeset_load_multiple($ids, $conditions = array(), $reset = FALSE) {
  return entity_load('cps_changeset', $ids, $conditions, $reset);
}

/**
 * Save a changeset entity.
 *
 * @param CPSChangeset $entity
 *   The entity to save.
 *
 * @see node_save()
 */
function cps_changeset_save(CPSChangeset $entity) {
  return entity_get_controller('cps_changeset')->save($entity);
}

/**
 * Delete a changeset entity.
 *
 * @param $changeset_id
 *   A changeset ID.
 */
function cps_changeset_delete($changeset_id) {
  cps_changeset_delete_multiple(array($changeset_id));
}

/**
 * Delete a revision for a changeset entity.
 *
 * @param $vid
 *   The revision id to delete.
 */
function cps_changeset_delete_revision($vid) {
  return entity_get_controller('cps_changeset')->deleteRevision($vid);
}

/**
 * Delete multiple changesets.
 *
 * @param string[] $changeset_ids
 *   An array of changeset IDs.
 */
function cps_changeset_delete_multiple(array $changeset_ids) {
  return entity_get_controller('cps_changeset')->delete($changeset_ids);
}

/**
 * View a changeset entity.
 *
 * @param CPSChangeset $entity
 *   The changeset entity.
 * @param string $view_mode
 *   The view mode to view.
 * @param string $langcode
 *   The language to use or NULL.
 *
 * @return array
 *   A Drupal renderable array.
 *
 * @see node_view()
 */
function cps_changeset_view(CPSChangeset $entity, $view_mode = 'full', $langcode = NULL) {
  return entity_get_controller('cps_changeset')->view($entity, $view_mode, $langcode);
}

/**
 * Callback to create a new entity.
 *
 * @param array $values
 *   The initial values to seed the new entity with.
 *
 * @return CPSChangeset
 */
function cps_changeset_create($values = array()) {
  return entity_get_controller('cps_changeset')->create($values);
}

/**
 * Determine if the operation for the entity can be accessed.
 *
 * @param string $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'. It may also be any changeset operation such as 'publish' or
 *   'unpublish'.
 * @param string|CPSChangeset $entity
 *   (optional) an entity to check access for. If no entity is given, it will be
 *   determined whether access is allowed for all entities of the given type.
 * @param stdClass|null $account
 *   The user to check for. Leave it to NULL to check for the global user.
 *
 * @return boolean
 *   Whether access is allowed or not. If the entity type does not specify any
 *   access information, NULL is returned.
 *
 * @see entity_access()
 */
function cps_changeset_access($op, $entity = NULL, $account = NULL) {
  return entity_get_controller('cps_changeset')->access($op, $entity, $account);
}

/**
 * Callback for getting content properties.
 *
 * @param CPSChangeset $changeset
 *   The changeset entity to get proprties for.
 * @param array $options
 *   The options provided by the caller.
 * @param $name
 *   The name of the property.
 *
 * @return mixed
 *   The result of the property.
 */
function cps_changeset_metadata_get_properties(CPSChangeset $changeset, array $options, $name) {
  switch ($name) {
    case 'is_new':
      return empty($changeset->changeset_id) || !empty($changeset->is_new);

    case 'edit_url':
      return url('admin/structure/changesets/' . $changeset->changeset_id . '/edit', $options);

    case 'delete_url':
      return url('admin/structure/changesets/' . $changeset->changeset_id . '/delete', $options);

    case 'author':
      return !empty($changeset->uid) ? $changeset->uid : drupal_anonymous_user();

    case 'operations':
      $build = cps_changeset_get_operations($changeset);
      return drupal_render($build);
  }
}

/**
 * Fetch a renderable array of changeset operations available for the changeset.
 *
 * @param CPSChangeset $changeset
 *   The changeset to get operations for.
 *
 * @return array
 *   A drupal Renderable array.
 */
function cps_changeset_get_operations(CPSChangeset $changeset) {
  $uri = $changeset->uri();
  $operations = array(
    '#type' => 'container',
    '#attributes' => array('class' => 'cps-changeset-operations'),
    'site' => array(
      '#theme' => 'link',
      '#text' => t('view site'),
      '#path' => '<front>',
      '#options' => array(
        'query' => array('changeset_id' => $changeset->changeset_id),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => user_access('preview changesets') || user_access('view changesets') || user_access('administer changesets'),
    ),
    'view' => array(
      '#theme' => 'link',
      '#text' => t('status'),
      '#path' => $uri['path'],
      '#options' => array(
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('view', 'cps_changeset', $changeset) && request_path() != $uri['path'],
    ),
    'edit' => array(
      '#theme' => 'link',
      '#text' => t('edit'),
      '#path' => $uri['path'] . '/edit',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('update', 'cps_changeset', $changeset),
    ),
    'delete' => array(
      '#theme' => 'link',
      '#text' => t('delete'),
      '#path' => $uri['path'] . '/delete',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('delete', 'cps_changeset', $changeset),
    ),
    'publish' => array(
      '#theme' => 'link',
      '#text' => t('publish'),
      '#path' => $uri['path'] . '/publish',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('publish', 'cps_changeset', $changeset),
    ),
    'unpublish' => array(
      '#theme' => 'link',
      '#text' => t('unpublish'),
      '#path' => $uri['path'] . '/unpublish',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('unpublish', 'cps_changeset', $changeset),
    ),
  );

  drupal_alter('cps_changeset_operations', $operations, $changeset);
  return $operations;
}

/**
 * Convenience function to test whether the current changeset is active.
 *
 * @return bool
 */
function cps_is_current_changeset_active() {
  return cps_get_current_changeset(TRUE) != CPS_PUBLISHED_CHANGESET;
}

/**
 * Determine if the 'switch to this site version' action should be visible.
 *
 * @param CPSChangeset $changeset
 *
 * @return bool
 */
function cps_changeset_view_site_access($changeset) {
  $current_changeset_id = cps_get_current_changeset();
  return $changeset && $current_changeset_id != $changeset->changeset_id && cps_changeset_access('view', $changeset);
}
