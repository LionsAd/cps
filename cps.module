<?php

/**
 * @file
 * Main module file for the Content Preview System.
 */

define('CPS_PUBLISHED_CHANGESET', FALSE);

// -----------------------------------------------------------------------
// Drupal Core Hooks

/**
 * Implements hook_boot().
 */
function cps_boot() {
  // If we are looking at a changeset, load overridden variables and add
  // them into $conf.

  // This isn't using cps_changeset_load() because that loads a bunch of things
  // that don't exist during hook_boot.
  if (variable_get('cps_override_variables', FALSE)) {
    $changeset_id = cps_get_current_changeset();
    if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
      $vars = db_query("SELECT variables FROM {cps_changeset} WHERE changeset_id = :changeset_id", array(':changeset_id' => $changeset_id))->fetchField();
      if ($vars) {
        global $conf;
        global $cps_conf;
        $cps_conf = unserialize($vars);

        if ($cps_conf) {
          foreach ($cps_conf as $name => $value) {
            $conf[$name] = $value;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_exit().
 */
function cps_exit() {
  if (variable_get('cps_override_variables', FALSE)) {
    global $cps_conf_changed;
    if (!empty($cps_conf_changed)) {
      $changeset_id = cps_get_current_changeset(TRUE);
      if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
        $changeset = cps_changeset_load($changeset_id);
        // Only write if $changeset->published is empty.
        if (empty($changeset->published)) {
          global $cps_conf;
          $changeset->variables = $cps_conf;
          $changeset->save();
        }
      }
    }
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function cps_module_implements_alter(&$implementations, $hook) {
  if (in_array($hook, array('entity_query_alter', 'views_query_alter'))) {
    // Move CPS's query alter after entity reference's so we can remove the
    // checks for published status.
    $temp = $implementations['cps'];
    unset($implementations['cps']);
    $implementations['cps'] = $temp;
  }
}

/**
 * Implements of hook_permission()
 */
function cps_permission() {
  return array(
    'administer changesets' => array(
      'title' => t('Administer site versions'),
      'description' => t('Add, delete, edit and manipulate site versions.'),
    ),
    'edit all changesets' => array(
      'title' => t('Edit all site versions'),
      'description' => t('Can edit site versions owned by other people.'),
    ),
    'view changesets' => array(
      'title' => t('View site versions'),
      'description' => t('View the site version widget and change the site preview accordingly.'),
    ),
    'preview changesets' => array(
      'title' => t('Preview site versions'),
      'description' => t('Preview site versions without being able to see the widget.'),
    ),
    'publish changesets' => array(
      'title' => t('Publish site versions'),
      'description' => t('Can publish site versions.'),
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function cps_entity_info() {
  $info = array();

  $info['cps_changeset'] = array(
    'label' => t('Site version'),
    'entity class' => 'CPSChangeset',
    'controller class' => 'CPSChangesetController',
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => 'cps_changeset',
    // After variants this will change to FALSE
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'changeset_id',
      'label' => 'name',
    ),
    'bundles' => array(
      'cps_changeset' => array(
        'label' => t('Site version'),
      ),
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full'),
        'custom settings' => FALSE,
      ),
      'embed' => array(
        'label' => t('Embedded'),
        'custom settings' => FALSE,
      ),
      'mail' => array(
        'label' => t('Mailed'),
        'custom settings' => FALSE,
      ),
    ),
    // entity module callbacks
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'view callback' => 'entity_metadata_view_single',
    'creation callback' => 'cps_changeset_create',
    'access callback' => 'cps_changeset_access',
    'save callback' => 'cps_changeset_save',
    'module' => 'cps',
  );

  return $info;
}

/**
 * Implements hook_menu().
 */
function cps_menu() {
  $items = array();
  $items['admin/structure/changesets/%cps_changeset'] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('cps_changeset', 3),
    'page callback' => 'cps_changeset_view_page',
    'page arguments' => array(3, 'full'),
    'access callback' => 'entity_access',
    'access arguments' => array('view', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/view'] = array(
    'title' => 'Status',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_edit_page',
    'page arguments' => array(3),
    'access callback' => 'entity_access',
    'access arguments' => array('update', 'cps_changeset', 3),
    'weight' => -9,
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/view-site'] = array(
    'title' => 'Switch to this version',
    'type' => MENU_LOCAL_ACTION,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_view_site_page',
    'page arguments' => array(3),
    'access callback' => 'entity_access',
    'access arguments' => array('view', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
    'weight' => -10,
  );


  $items['admin/structure/changesets/%cps_changeset/publish'] = array(
    'title' => 'Publish',
    'type' => MENU_LOCAL_ACTION,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_publish_page',
    'page arguments' => array(3),
    'access callback' => 'entity_access',
    'access arguments' => array('publish', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/unpublish'] = array(
    'title' => 'Unpublish',
    'type' => MENU_LOCAL_ACTION,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_unpublish_page',
    'page arguments' => array(3),
    'access callback' => 'entity_access',
    'access arguments' => array('unpublish', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/delete'] = array(
    'title' => 'Delete',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cps_changeset_delete_form', 3),
    'access callback' => 'entity_access',
    'access arguments' => array('delete', 'cps_changeset', 3),
    'weight' => -8,
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/remove/%/%'] = array(
    'title' => 'Remove',
    'type' => MENU_CALLBACK,
    'page callback' => 'cps_changeset_remove_page',
    'page arguments' => array(3, 5, 6),
    'access callback' => 'entity_access',
    'access arguments' => array('update', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/move/%/%'] = array(
    'title' => 'Move',
    'type' => MENU_CALLBACK,
    'page callback' => 'cps_changeset_move_page',
    'page arguments' => array(3, 5, 6),
    // Handle access checking in the callback as its a bit complex for here.
    'access callback' => TRUE,
    'file' => 'includes/admin.inc',
  );

  if (module_exists('devel')) {
    $items['admin/structure/changesets/%cps_changeset/devel'] = array(
      'title' => 'Devel',
      'page callback' => 'devel_load_object',
      'page arguments' => array('cps_changeset', 3),
      'access arguments' => array('access devel information'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 100,
      'file' => 'devel.pages.inc',
      'file path' => drupal_get_path('module', 'devel'),
    );

    $items['admin/structure/changesets/%cps_changeset/devel/load'] = array(
      'title' => 'Load',
      'type' => MENU_DEFAULT_LOCAL_TASK,
    );

    $items['admin/structure/changesets/%cps_changeset/devel/render'] = array(
      'title' => 'Render',
      'page callback' => 'devel_render_object',
      // Normally this would be the name of the entity type, but slightly
      // modified in order to call the right function.
      'page arguments' => array('cps_changeset', 3),
      'access arguments' => array('access devel information'),
      'file' => 'devel.pages.inc',
      'file path' => drupal_get_path('module', 'devel'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 100,
    );
  }

  $items['admin/structure/changesets'] = array(
    'title' => 'Site versions',
    'description' => 'Manage changesets.',
    'page callback' => 'cps_changeset_list_page',
    'page arguments' => array('administer_changesets'),
    'file' => 'includes/admin.inc',
    'access arguments' => array('administer changesets'),
    'weight' => -10,
  );

  $items['admin/structure/changesets/open'] = array(
    'title' => 'Open',
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/structure/changesets/archived'] = array(
    'title' => 'Archive',
    'page callback' => 'cps_changeset_list_page',
    'page arguments' => array('archived_changesets'),
    'file' => 'includes/admin.inc',
    'access arguments' => array('administer changesets'),
    'weight' => 10,
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/structure/changesets/add'] = array(
    'title' => 'Add site version',
    'page callback' => 'cps_changeset_add_entity_page',
    'page arguments' => array(),
    'access arguments' => array('administer changesets'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/admin.inc',
  );

  return $items;
}

/**
 * Implements hook_entity_load().
 */
function cps_entity_load(&$entities, $entity_type) {
  $entity_info = entity_get_info($entity_type);
  if (empty($entity_info['entity keys']['revision'])) {
    return;
  }
  // When a non-default revision is being loaded, don't overwrite any of the
  // contents of that revision.
  foreach ($entities as $entity) {
    // If a revision was requested, then there is only going to be one entity
    // in the list. We don't touch entity loading when a specific revision was
    // requested.
    // When the new drafty dependency is added, drafty module may not actually
    // be enabled, and this can cause fatal errors on sites that load entities
    // during bootstrap, so check for module existence.
    if (module_exists('drafty') && drafty()->wasRevisionRequested($entity)) {
      return;
    }
  }

  $changeset = cps_get_current_changeset();
  // Fetch entity state information for not published changesets OR the current
  // one. We ignore published changesets because those will accrete over time
  // and are generally irrelevant to our needs.
  $keys = array_keys($entities);

  // @todo: should this include the actual 'published' changeset, that has
  // published = 0 so is included in the query currently.
  $changesets = cps_get_unpublished_changesets();
  if ($changeset) {
    $changesets[] = $changeset;
  }
  $result = db_query('SELECT * FROM {cps_entity} WHERE entity_type = :entity_type AND entity_id IN (:ids) AND changeset_id IN (:changesets)', array(':entity_type' => $entity_type, ':ids' => $keys, ':changesets' => $changesets));
  foreach ($result as $entity_state) {
    $entities[$entity_state->entity_id]->changeset[$entity_state->changeset_id] = $entity_state;
  }

  // We only care further if the current changeset is not the published one.
  if (!$changeset) {
    return;
  }

  $revision_key = $entity_info['entity keys']['revision'];

  foreach ($entities as $entity) {
    list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);

    // If this entity has a revision set for the current change set,
    // we need to swap it out for the correct revision.
    if (!empty($entity->changeset[$changeset]) && $revision_id != $entity->changeset[$changeset]->revision_id) {

      $swap_revision_id = $entity->changeset[$changeset]->revision_id;
      $draft_revisions = entity_load($entity_type, array($entity_id), array($revision_key => $swap_revision_id));

      // Swap the entity!
      if (!empty($draft_revisions[$entity_id])) {
        $new_entity = $entities[$entity_id] = $draft_revisions[$entity_id];
        $new_entity->changeset = $entity->changeset;
        // Store the current revision ID so we can tell later if we need to put it back.
        $new_entity->published_revision_id = $revision_id;
        $new_entity->published_revision = clone($entity);
        // Tell entity API not to save this as the default revision:
        $new_entity->default_revision = FALSE;
        $entities[$entity_id] = $new_entity;
      }
      else {
        // This state is invalid, and all we can do is remove the changeset from the list.
        unset($entity->changeset[$changeset]);
      }
    }
  }
}

/**
 * Get all unpublished changesets.
 */
function cps_get_unpublished_changesets() {
  $changesets = &drupal_static(__FUNCTION__);
  if (!isset($changesets)) {
    $changesets = db_query('SELECT changeset_id FROM {cps_changeset} WHERE published = 0')->fetchCol();
  }
  return $changesets;
}

/**
 * Implements hook_entity_presave().
 */
function cps_entity_presave($entity, $entity_type) {
  cps_set_revision_log($entity);
}

/**
 * Implements hook_entity_insert().
 */
function cps_entity_insert($entity, $entity_type) {
 // When an new entity is inserted, we actually want two revisions to be saved.
 //  - An unpublished revision in the 'published' changeset, since CPS treats
 //    any entity that's never been published as 'unpublished'.
 //  - A draft revision in the current changeset with the published flag set to
 //    the same as on the node form.
  $changeset = cps_get_current_changeset();
  if (!$changeset) {
    return;
  }


  if (cps_is_supported($entity_type)) {
    list($entity_id, $revision_id) = entity_extract_ids($entity_type, $entity);
    db_insert('cps_entity')
      ->fields(array(
        'entity_type' => $entity_type,
        'entity_id' => $entity_id,
        'changeset_id' => $changeset,
        'revision_id' => $revision_id,
     ))->execute();
    // Operate on a clone to avoid changing the entity prior to subsequent
    // hook_entity_insert() implementations.
    $live_revision = clone $entity;

    // The entity is no longer new.
    unset($live_revision->is_new);

    entity_status_set($entity_type, $live_revision, ENTITY_UNPUBLISHED);

    $live_revision->cps_initial_unpublished = TRUE;
    module_invoke_all('cps_live_revision', $entity_type, $live_revision);
    entity_save($entity_type, $live_revision);
  }
}

/**
 * Implements hook_entity_update().
 */
function cps_entity_update($entity, $entity_type) {
  $changeset = cps_get_current_changeset();
  // If we are not on a change set, do nothing.
  if (!$changeset) {
    return;
  }

  // If this isn't a draft revision, do nothing.
  if (!drafty()->isDraftRevision($entity) && empty($entity->cps_initial_unpublished)) {
    return;
  }

  if (!empty($entity->cps_initial_unpublished)) {
    $changeset = 'initial';
  }

  list($entity_id, $revision_id) = entity_extract_ids($entity_type, $entity);
  // Store state information.
  db_merge('cps_entity')
    ->key(array(
      'entity_type' => $entity_type,
      'entity_id' => $entity_id,
      'changeset_id' => $changeset,
    ))
    ->fields(array(
      'revision_id' => $revision_id,
    ))
    ->execute();
}

/**
 * Implements hook_entity_delete().
 */
function cps_entity_delete($entity, $entity_type) {
  list($entity_id) = entity_extract_ids($entity_type, $entity);
  db_delete('cps_entity')
    ->condition('entity_type', $entity_type)
    ->condition('entity_id', $entity_id)
    ->execute();
}

/**
 * Implements hook_field_attach_delete_revision().
 */
function cps_field_attach_delete_revision($entity_type, $entity) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);
  db_delete('cps_entity')
    ->condition('entity_type', $entity_type)
    ->condition('revision_id', $revision_id)
    ->condition('entity_id', $entity_id)
    ->execute();
}

/**
 * Implements hook_entity_query_alter().
 *
 * @param $query
 */
function cps_entity_query_alter($query) {
  // Do not muck with EFQ queries if there is not a changeset active.
  $changeset_id = cps_get_current_changeset(TRUE);
  if ($changeset_id == CPS_PUBLISHED_CHANGESET) {
    return;
  }

  // Ignore specific queries for historical data.
  if ($query->age != FIELD_LOAD_CURRENT) {
    return;
  }

  // Broken with changesets, ignore.
  if (empty($query->entityConditions['entity_type'])) {
    return;
  }

  // Only bother if it's a supported, revisioned entity type.
  $entity_type = $query->entityConditions['entity_type']['value'];
  if (!cps_is_supported($entity_type)) {
    return;
  }

  $query->executeCallback = 'cps_field_sql_storage_field_storage_query';
}

/**
 * Replacement for field_sql_storage_field_storage_query().
 *
 * This function replaces the original so that we can take into account changesets.
 * It is a copy that has been heavily modified.
 *
 * It does the following things differently:
 * * Select on entity_base_table as top table instead of field_base_table.
 *
 * * Join the CPS table to either include live content or restrict to the content
 *   at the time of the publishing.
 *
 * * Use field revision tables based on the CPS revision to fetch the data from.
 *
 * * Check if properties exist on the entity revision table, if so use those, else use
 *   the ones on the entity base table.
 */
function cps_field_sql_storage_field_storage_query(EntityFieldQuery $query) {
  $changeset_id = cps_get_current_changeset();
  $changeset = cps_changeset_load($changeset_id);

  $entity_type = $query->entityConditions['entity_type']['value'];
  $entity_info = entity_get_info($entity_type);
  $entity_id_key = $entity_info['entity keys']['id'];
  $revision_id_key = $entity_info['entity keys']['revision'];
  $bundle_key = $entity_info['entity keys']['bundle'];
  $entity_base_table = $entity_info['base table'];

  // Unlike the original, we always use the entity table as the base table.
  // We can do this because we have verified that there is an entity type
  // involved in the query prior to this function being run.
  $select_query = db_select($entity_base_table, $entity_base_table);

  // Allow queries internal to the Field API to opt out of the access
  // check, for situations where the query's results should not depend on
  // the access grants for the current user.
  if (!isset($query->tags['DANGEROUS_ACCESS_CHECK_OPT_OUT'])) {
    $select_query->addTag('entity_field_access');
  }

  // This adds all of the base fields that are expected so that it can create
  // a pseudo entity when reading the results.
  $select_query->addMetaData('base_table', $entity_base_table);
  $select_query->addExpression("'$entity_type'", 'entity_type');
  $select_query->addField($entity_base_table, $entity_id_key, 'entity_id');
  $select_query->addField($entity_base_table, $revision_id_key, 'revision_id');
  // The bundle key is optional in the case where the entity type only has one
  // bundle.
  if ($bundle_key) {
    $select_query->addField($entity_base_table, $bundle_key, 'bundle');
  }

  // If the changeset has been published, we INNER join to exclude content that did not exist when
  // the changeset was published. If it has not, we LEFT join so we can properly include live
  // content along with the changeset.
  $join_type = $changeset->published ? 'INNER' : 'LEFT';
  $select_query->addJoin($join_type, 'cps_entity', 'cps_entity', "cps_entity.entity_type = '$entity_type' AND cps_entity.entity_id = $entity_base_table.$entity_id_key AND cps_entity.changeset_id = '$changeset_id'");

  $table_aliases = array();
  // Add tables for the fields used.
  foreach ($query->fields as $key => $field) {
    // The original used $tablename_function here, which was checked based on $query->age
    // Because we're going through cps_entity and looking at revisions, we always join
    // the field revision table instead of the current table.
    $tablename = _field_sql_storage_revision_tablename($field);
    // Every field needs a new table.
    $table_alias = $tablename . $key;

    // Set the first field as the field_base_table which is still used for some bits.
    if ($key == 0) {
      $field_base_table = $table_alias;
    }
    $table_aliases[$key] = $table_alias;
    // This coalesce allows us to join the specific revision for the changeset, or the
    // current revision if no changeset exists.
    $select_query->join($tablename, $table_alias, "$table_alias.entity_type = '$entity_type' AND $table_alias.revision_id = COALESCE(cps_entity.revision_id, $entity_base_table.$revision_id_key)");
    if ($field['cardinality'] != 1 || $field['translatable']) {
      $select_query->distinct();
    }
  }

  // Add field conditions. We need a fresh grouping cache.
  drupal_static_reset('_field_sql_storage_query_field_conditions');
  _field_sql_storage_query_field_conditions($query, $select_query, $query->fieldConditions, $table_aliases, '_field_sql_storage_columnname');

  // Add field meta conditions.
  _field_sql_storage_query_field_conditions($query, $select_query, $query->fieldMetaConditions, $table_aliases, '_field_sql_storage_query_columnname');

  // This still uses the $field_base_table because entity_base_table does not have this field.
  if (isset($query->deleted) && isset($field_base_table)) {
    $select_query->condition("$field_base_table.deleted", (int) $query->deleted);
  }

  // Is there a need to sort the query by property?
  $has_property_order = FALSE;
  foreach ($query->order as $order) {
    if ($order['type'] == 'property') {
      $has_property_order = TRUE;
    }
  }

  if ($query->propertyConditions || $has_property_order) {
    // We always add the revision table if we have a property order or condition. It is
    // actually possible the revision table will be added unnecessarily but it is
    // difficult to check prior to adding the table without accidentally adding
    // the table multiple times.
    $revision_table = $entity_info['revision table'];
    $select_query->join($revision_table, $revision_table, "$revision_table.$revision_id_key = COALESCE(cps_entity.revision_id, $entity_base_table.$revision_id_key)");
    $query->entityConditions['entity_type']['operator'] = '=';

    // Check to see if the property exists on the revision table. If it does, use that instead
    // so that we can properly see the revision. If not, default to the entity base table.
    foreach ($query->propertyConditions as $property_condition) {
      if (in_array($property_condition['column'], $entity_info['schema_fields_sql']['revision table'])) {
        $query->addCondition($select_query, "$revision_table." . $property_condition['column'], $property_condition);
      }
      else {
        $query->addCondition($select_query, "$entity_base_table." . $property_condition['column'], $property_condition);
      }
    }
  }

  foreach ($query->entityConditions as $key => $condition) {
    switch ($key) {
      case 'entity_id':
        $field = $entity_id_key;
        break;
      case 'revision_id':
        $field = $revision_id_key;
        break;
      case 'bundle':
        $field = $bundle_key;
        break;
      default:
        $field = NULL;
    }
    if ($field) {
      $query->addCondition($select_query, "$entity_base_table.$field", $condition);
    }
  }

  // Order the query.
  foreach ($query->order as $order) {
    if ($order['type'] == 'entity') {
      // Entity ordering is similar to entity conditions above.
      $key = $order['specifier'];
      switch ($key) {
        case 'entity_id':
          $field = $entity_id_key;
          break;
        case 'revision_id':
          $field = $revision_id_key;
          break;
        case 'bundle':
          $field = $bundle_key;
          break;
        default:
          $field = NULL;
      }
      $select_query->orderBy("$entity_base_table.$field", $order['direction']);
    }
    elseif ($order['type'] == 'field') {
      $specifier = $order['specifier'];
      $field = $specifier['field'];
      $table_alias = $table_aliases[$specifier['index']];
      $sql_field = "$table_alias." . _field_sql_storage_columnname($field['field_name'], $specifier['column']);
      $select_query->orderBy($sql_field, $order['direction']);
    }
    elseif ($order['type'] == 'property') {
      // Like property conditions above, check if it is in the revision table.
      if (in_array($order['specifier'], $entity_info['schema_fields_sql']['revision table'])) {
        $select_query->orderBy("$revision_table." . $order['specifier'], $order['direction']);
      }
      else {
        $select_query->orderBy("$entity_base_table." . $order['specifier'], $order['direction']);
      }
    }
  }

  return $query->finishQuery($select_query, 'entity_id');
}

function cps_form_views_exposed_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form_state['view']) && ($form_state['view']->tag == 'cps' || $form_state['view']->tag == 'only mine') && isset($form['uid_current'])) {
    $form['uid_current']['#options'] = array(
      'All' => t('All'),
      '1' => t('Only mine'),
    );
  }
}

// -----------------------------------------------------------------------
// Contrib Hooks

/**
 * Implements hook_ctools_plugin_directory().
 */
function cps_ctools_plugin_directory($module, $plugin) {
  if ($module == 'cps') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_iib_page_item().
 */
function cps_iib_page_item() {
  if (user_access('view changesets')) {
    $path = drupal_get_path('module', 'cps');
    ctools_include('forms', 'cps');
    $items['left'] = array(
      '#weight' => -10,
      'form' => drupal_get_form('cps_changeset_preview_form'),
      '#attached' => array(
        'css' => array("$path/css/cps.css"),
        'js' => array(
          "$path/js/cps.js",
          array(
            'data' => array(
              'cps' => array('changeset_id' => cps_get_current_changeset(TRUE)),
            ),
            'type' => 'setting',
          ),
        ),
      ),
    );
    return $items;
  }
}

/**
 * Implements hook_iib_hidden_alter().
 */
function cps_iib_hidden_alter(&$hidden) {
  $hidden = FALSE;
}

/**
 * Implements hook_ctools_plugin_api().
 */
function cps_ctools_plugin_api($module, $api) {
  if ($module == 'cps' && $api == 'cps') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_views_api().
 */
function cps_views_api() {
  return array(
    'path' => drupal_get_path('module', 'cps') . '/plugins/views',
    'api' => 3,
  );
}

/**
 * Implements hook_views_query_alter().
 */
function cps_views_query_alter($view, $query) {
  $changeset = cps_get_current_changeset(TRUE);

  // Do not modify queries while viewing the published changeset.
  if ($changeset == CPS_PUBLISHED_CHANGESET) {
    return;
  }

  // Find out what entity types are represented in this query.
  $entity_types = array();
  foreach ($query->relationships as $info) {
    $table_data = views_fetch_data($info['base']);
    if (empty($table_data['table']['entity type'])) {
      continue;
    }
    $entity_type = $table_data['table']['entity type'];
    // This construct ensures each entity_type exists only once.
    $entity_types[$entity_type] = $entity_type;
  }

  foreach ($entity_types as $entity_type) {
    if (cps_is_supported($entity_type)) {
      cps_views_query_alter_entity($view, $query, $entity_type);
    }
  }
}

/**
 * Helper for cps_views_queryAlter().
 */
function cps_views_query_alter_entity($view, $query, $entity_type) {
  // This is only called if the system has already determined that this entity type
  // is involved in the query, and that a changeset is in use.

  $move_cps_entities = array();
  // Start $index at -1 so it will immediately be 0.
  $index = -1;
  $entity_info = entity_get_info($entity_type);
  foreach ($query->table_queue as $alias => &$table_info) {
    // Update $index early because we might continue later.
    $index++;

    // If we reach the cps_entity array item before any candidates, then we
    // do not need to move it.
    if ($table_info['table'] == 'cps_entity') {
      break;
    }

    // Any table named field_data_* is a candidate.
    if (strpos($table_info['table'], 'field_data_') === 0) {
      $relationship = $table_info['relationship'];
      // See if it is our entity type.
      // While it may seem inefficient to check entity type individually,
      // non-revisioned entities might have field_data_* fields and we do NOT want
      // to muck with those by accident!
      $table_data = views_fetch_data($query->relationships[$relationship]['base']);
      if (empty($table_data['table']['entity type']) || $table_data['table']['entity type'] != $entity_type) {
        continue;
      }

      // There can be reverse relationships used; if so, CPS can't do anything with them.
      // Detect this and skip:
      if ($table_info['join']->field != 'entity_id') {
        continue;
      }

      // Calculate the revision table name. field_data_ is 11 characters long.
      $new_table_name = 'field_revision_' . substr($table_info['table'], 11);

      // Now add the cps_entity table.
      $cps_entity_table = cps_ensure_cps_table($entity_type, $query, $relationship);

      // Update the join to use our coalesce
      $revision_field = $entity_info['entity keys']['revision'];
      $table_info['join']->left_table = NULL;
      $table_info['join']->left_field = "COALESCE($cps_entity_table.revision_id, $relationship.$revision_field)";

      // Update the join and the table info to our new table name, and to join on the revision key.
      $table_info['table'] = $new_table_name;
      $table_info['join']->table = $new_table_name;
      $table_info['join']->field = 'revision_id';

      // Finally, if we added the cps entity table we have to move it in the table_queue so that it
      // comes before this field.
      if (empty($move_cps_entities[$cps_entity_table])) {
        $move_cps_entities[$cps_entity_table] = $alias;
      }
    }
  }

  // JOINs must be in order. i.e, any tables you mention in the ON clause of a JOIN
  // must appear prior to that JOIN. Since we're modifying a JOIN in place,
  // and adding a new table, we must ensure that new table appears prior
  // to this one. So we recorded at what index we saw that table, and then
  // use array_splice() to move the cps_entity table join to the right position.
  foreach ($move_cps_entities as $cps_entity_table => $alias) {
    // Find the index of the $alias in table_queue keys.
    $keys = array_keys($query->table_queue);
    $index = array_search($alias, $keys);
    $splice = array($cps_entity_table => $query->table_queue[$cps_entity_table]);
    unset($query->table_queue[$cps_entity_table]);

    // Now move the item to the proper location in the array. Don't use array_splice
    // because that breaks indices.
    $query->table_queue = array_slice($query->table_queue, 0, $index, TRUE) +
      $splice +
      array_slice($query->table_queue, $index, NULL, TRUE);
  }

  $entity_table = $entity_info['base table'];
  $test_fields = cps_get_revision_fields($entity_type);
  // Go through and look to see if we have to modify fields and filters
  // for $entity_table.status, $entity_table.sticky.
  // but we currently do not use those fields.
  foreach ($query->fields as &$field_info) {
    // Some fields don't actually have tables, meaning they're formulae and
    // whatnot. At this time we are going to ignore those.
    if (empty($field_info['table'])) {
      continue;
    }

    // Dereference the alias into the actual table.
    $table = $query->table_queue[$field_info['table']]['table'];
    if ($table == $entity_table && in_array($field_info['field'], $test_fields)) {
      $relationship = $query->table_queue[$field_info['table']]['alias'];
      $alias = cps_ensure_revision_table($entity_type, $query, $relationship);
      if ($alias) {
        // Change the base table to use the revision table instead.
        $field_info['table'] = $alias;
      }
    }
  }

  $relationships = array();
  // Build a list of all relationships that might be for our table.
  foreach ($query->relationships as $relationship => $info) {
    if ($info['base'] == $entity_table) {
      $relationships[] = $relationship;
    }
  }

  // Now we have to go through our where clauses and modify any of our fields.
  foreach ($query->where as &$clauses) {
    foreach ($clauses['conditions'] as &$where_info) {
      // Build a matrix of our possible relationships against fields we need to
      // switch.
      foreach ($relationships as $relationship) {
        foreach ($test_fields as $field) {
          if (is_string($where_info['field']) && $where_info['field'] == "$relationship.$field") {
            $alias = cps_ensure_revision_table($entity_type, $query, $relationship);
            if ($alias) {
              // Change the base table to use the revision table instead.
              $where_info['field'] = "$alias.$field";
            }
          }
        }
      }
    }
  }
}

/**
 * Helper for hook_views_query_alter().
 */
function cps_ensure_cps_table($entity_type, $query, $relationship) {
  $changeset_id = cps_get_current_changeset();
  $changeset = cps_changeset_load($changeset_id);

  if (isset($query->tables[$relationship]['cps_entity'])) {
    return $query->tables[$relationship]['cps_entity']['alias'];
  }

  $table_data = views_fetch_data($query->relationships[$relationship]['base']);

  // Construct the join.
  $join = new views_join();
  $join->definition = array(
    'table' => 'cps_entity',
    'field' => 'entity_id',
    'left_table' => $relationship,
    'left_field' => $table_data['table']['base']['field'],
    'extra' => array(
      array(
        'field' => 'entity_type',
        'value' => $entity_type,
      ),
      array(
        'field' => 'changeset_id',
        'value' => $changeset_id,
      )
    ),
    'type' => $changeset->published ? 'INNER' : 'LEFT',
  );

  $join->construct();
  $join->adjusted = TRUE;

  return $query->queue_table('cps_entity', $relationship, $join);
}

/**
 * Add the revision table for the entity type for the current changeset to a query.
 *
 * @param views_plugin_query $query
 *   The views query plugin.
 * @param string $relationship
 *   The name of the relationship.
 *
 * @return string $alias
 *   The alias of the relationship.
 */
function cps_ensure_revision_table($entity_type, $query, $relationship) {
  // Get the alias for the {cps_entity} table we chain off of in the COALESCE
  $cps_entity_table = cps_ensure_cps_table($entity_type, $query, $relationship);

  // Get the name of the revision table and revision key.
  $entity_info = entity_get_info($entity_type);
  $table = $entity_info['revision table'];
  $field = $entity_info['entity keys']['revision'];

  // Add this table only once.
  if (isset($query->tables[$relationship][$table])) {
    return $query->tables[$relationship][$table]['alias'];
  }

  // Construct the join.
  $join = new views_join();
  $join->definition = array(
    'table' => $table,
    'field' => $field,
    // Making this explicitly null allows $left_table to be a formula
    'left_table' => NULL,
    'left_field' => "COALESCE($cps_entity_table.revision_id, $relationship.$field)",
  );

  $join->construct();
  $join->adjusted = TRUE;

  return $query->queue_table($table, $relationship, $join);
}

/**
 * Fetch a list of fields that exist on both the revision and the main table.
 * @return array
 */
function cps_get_revision_fields($entity_type) {
  $entity_info = entity_get_info($entity_type);
  $base_schema = drupal_get_schema($entity_info['base table']);
  $revision_schema = drupal_get_schema($entity_info['revision table']);

  $fields = array();
  foreach ($revision_schema['fields'] as $name => $info) {
    if (isset($base_schema['fields'][$name]) && $name != $entity_info['entity keys']['id'] && $name != $entity_info['entity keys']['revision']) {
      $fields[] = $name;
    }
  }

  return $fields;
}

/**
 * Sets the revision log for an entity.
 */
function cps_set_revision_log($entity) {
  $current_changeset = cps_get_current_changeset();
  if ($current_changeset) {
    $changeset = cps_changeset_load($current_changeset);
    if ($changeset) {
      $name = $changeset->name;
    }
    else {
      $name = $current_changeset;
    }
  }
  else {
    $name = 'Published';
  }
  $entity->log = t('Revision for site version %changeset', array('%changeset' => $name));
}

/**
 * Implements hook_entity_property_info().
 */
function cps_entity_property_info() {
  return entity_get_controller('cps_changeset')->hook_entity_property_info();
}

/**
 * Implements hook_entitycache_load_alter().
 */
function cps_entitycache_load_alter(&$entities) {
  if (cps_get_current_changeset() !== CPS_PUBLISHED_CHANGESET) {
    // If the state is not empty, do not let entitycache load things from cache.
    $entities = array();
  }
}

/**
 * Implements hook_entitycache_save_alter().
 */
function cps_entitycache_save_alter(&$entities) {
  if (cps_get_current_changeset() !== CPS_PUBLISHED_CHANGESET) {
    // If the state is not empty, do not let entitycache save things in cache.
    $entities = array();
  }
}

// -----------------------------------------------------------------------
// Public API

/**
 * Fetch the currently in use changeset.
 *
 * @param $test
 *   If TRUE, test to ensure the changeset is valid.
 *
 * @return string
 *   The current changeset id.
 */
function cps_get_current_changeset($test = FALSE) {

  if (isset($GLOBALS['cps_override_changeset'])) {
    return $GLOBALS['cps_override_changeset'];
  }
  if (!function_exists('user_access')) {
    drupal_load('module', 'user');
  }

  if (!drupal_is_cli() && !user_access('preview changesets') && !user_access('view changesets') && !user_access('administer changesets')) {
    return CPS_PUBLISHED_CHANGESET;
  }

  if (isset($_GET['changeset_id'])) {
    $changeset_id = $_GET['changeset_id'];
    $_SESSION['changeset_id'] = $changeset_id;
  }
  elseif (isset($_SESSION['changeset_id'])) {
    $changeset_id = $_SESSION['changeset_id'];
  }
  else {
    $changeset_id = CPS_PUBLISHED_CHANGESET;
  }

  // Use a $test flag because there are phases where we do not want to invoke
  // a load.
  if ($test && $changeset_id) {
    $changeset = cps_changeset_load($changeset_id);
    if (!$changeset) {
      $changeset_id = CPS_PUBLISHED_CHANGESET;
    }
  }
  
  // Record that we have touched this changeset.
  if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
    $_SESSION['touched changesets'][$changeset_id] = REQUEST_TIME;
  }

  return $changeset_id;
}

/**
 * Set the current changeset.
 *
 * @param string $changeset_id
 *   The changeset id.
 */
function cps_set_current_changeset($changeset_id) {
  if (isset($changeset_id)) {
    $_SESSION['changeset_id'] = $changeset_id;
  }
  elseif (isset($_SESSION['changeset_id'])) {
    unset($_SESSION['changeset_id']);
  }
}

/**
 * Set a global override for the current changeset.
 *
 * @param $changeset_id
 */
function cps_override_changeset($changeset_id) {
  global $cps_override_changeset;
  $cps_override_changeset = $changeset_id;

  // We have to reset the entity static cache because changing this could poison
  // the cache.
  foreach (entity_get_info() as $entity_type => $entity_info) {
    if (cps_is_supported($entity_type)) {
      entity_get_controller($entity_type)->resetCache();
    }
  }
}

/**
 * Check whether CPS is supported for an entit type.
 *
 * @param string $entity_type
 */
function cps_is_supported($entity_type) {
  $info = entity_get_info($entity_type);
  return !empty($info['cps']);
}

/**
 * Get supported entity types.
 */
function cps_get_supported() {
  $types = array();
  $info = entity_get_info();
  foreach ($info as $entity_type => $entity_info) {
    if (!empty($entity_info['cps'])) {
      $types[] =  $entity_type;
    }
  }
  return $types;
}

/**
 * @{inheritdoc}
 */
function cps_make_revision_published($entity_type, $entity_id, $changeset_id) {

  cps_override_changeset(CPS_PUBLISHED_CHANGESET);
  // Find the revision id.
  $revision_id = db_query('SELECT revision_id FROM {cps_entity} WHERE entity_type = :entity_type AND entity_id = :entity_id AND changeset_id = :changeset',
  array(
    ':entity_type' => $entity_type,
    ':entity_id' => $entity_id,
    ':changeset' => $changeset_id,
  ))->fetchField();

  drafty()->publishRevision($entity_type, $entity_id, $revision_id);
  cps_override_changeset(NULL);
}

/**
 * Determine if entity editing is allowable.
 *
 * We disallow the editing or creation of entities and anything else managed by
 * changesets when viewing the published changeset (i.e, the live site) or when
 * viewing a previously published changeset (i.e, an archive view).
 *
 * @param $op
 *   The operation to check. Any $op which isn't view' is considered an edit,
 *   so non-privileged non-view operations should be filtered by the caller.
 * @param string $entity_type
 *   The type of entity to test.
 * @param $entity
 *   The entity to check.
 * @param $changeset_id
 *   The changeset to check against. If not specified the currently active changeset
 *   will be used.
 *
 * @return bool
 */
function cps_can_edit_entities($op, $entity_type, $entity, $changeset_id = NULL) {
  // Deletions can occur outside of a changeset if the content was never published.
  if ($op == 'delete') {
    return cps_can_delete_entity($entity_type, $entity);
  }

  if (!isset($changeset_id)) {
    $changeset_id = cps_get_current_changeset(TRUE);
  }

  if ($op == 'view') {
    if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
      return TRUE;
    }

    if (entity_status_supported($entity_type)) {
      return entity_status_get($entity_type, $entity);
    }
    else {
      return TRUE;
    }
  }

  // The live changeset can never be edited for any reason, and we just bounce
  // it out early, without even letting other modules get involved.
  if ($changeset_id == CPS_PUBLISHED_CHANGESET) {
    return FALSE;
  }

  $changeset = cps_changeset_load($changeset_id);

  // Only unpublished changesets allow editing.
  $access = $changeset->status == 'unpublished';

  // Unless the user has edit all changesets, they can only make changes in
  // their own.
  if (!user_access('edit all changesets') && $GLOBALS['user']->uid != $changeset->uid) {
    $access = FALSE;
  }

  // If $op == 'move to' they cannot make this change if the entity already has
  // a revision in the changeset.
  if ($op == 'move to') {
    if ($entity && !empty($entity->changeset[$changeset_id])) {
      $access = FALSE;
    }
  }

  // Allow other modules to change this if needed.
  $context = array(
    'op' => $op,
    'entity_type' => $entity_type,
    'entity' => $entity,
    'changeset' => $changeset,
  );
  drupal_alter('cps_can_edit_entities', $access, $context);
  return $access;
}

/**
 * Determine if an entity can be deleted.
 * 
 * Once an entity has appeared in a published changeset, the entity should
 * not be deletable so that the site history is preserved. Instead, entities
 * should be unpublished which will make them disappear from standard view.
 * 
 * This method ONLY checks for CPS reasons, and the entity is expected
 * to do its own access control.
 * 
 * @param string $entity_type
 *   The type of entity to test.
 * @param $entity
 *   The entity to check.
 * @return bool
 *   TRUE if the entity can be deleted, FALSE if not.
 */
function cps_can_delete_entity($entity_type, $entity) {
  list($entity_id) = entity_extract_ids($entity_type, $entity);

  // Fetch a list of revisions directly joining to the cps table to find
  // revisions that point to published changesets.
  $entity_info = entity_get_info($entity_type);
  $revision_table = $entity_info['revision table'];
  $id_field = $entity_info['entity keys']['id'];
  $revision_field = $entity_info['entity keys']['revision'];

  $result = db_query("SELECT DISTINCT base.$revision_field FROM {" . $revision_table . "} base LEFT JOIN {cps_entity} c ON base.$id_field = c.entity_id AND base.$revision_field = c.revision_id AND c.entity_type = '$entity_type' LEFT JOIN {cps_changeset} cs ON cs.changeset_id = c.changeset_id WHERE base.$id_field = :entity_id AND cs.published <> 0", array(':entity_id' => $entity_id))->fetchCol();

  if (!$result) {
    return TRUE;
  }

  if (!entity_status_supported($entity_type)) {
    return FALSE;
  }

  // If we do have a result, go through each revision and see if any are published. If any are,
  // deny.
  foreach ($result as $revision_id) {
    $revision = entity_revision_load($entity_type, $revision_id);
    if ($revision && entity_status_get($entity_type, $revision)) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Gets the available changesets for the widget.
 *
 * @return string[]
 *   The list of available changesets, keyed by ID.
 */
function cps_get_changesets() {
  global $user;
  try {
    $query = new EntityFieldQuery();
    $results = $query->entityCondition('entity_type', 'cps_changeset')
      ->propertyCondition('status', 'archived', '<>')
      ->propertyCondition('uid', $user->uid)
      ->propertyOrderBy('name')
      // This tag allows another module to modify this list if necessary.
      ->addTag('cps_active_changeset_list')
      ->execute();
  }
  catch (Exception $e) {
    return array();
  }

  $changesets = array();
  if (!empty($results['cps_changeset'])) {
    $entities = cps_changeset_load_multiple(array_keys($results['cps_changeset']));
    foreach ($entities as $id => $entity) {
      $changesets[$id] = $entity->name;
    }
  }

  $published = array(
    0 => t('Live'),
  );

  $recent = array();
  $my_published = array();
  // Go through any changesets they have viewed within the last 24 hours
  // and create a list of them.
  if (!empty($_SESSION['touched changesets'])) {
    $recent_ids = array();
    foreach ($_SESSION['touched changesets'] as $id => $timestamp) {
      if ($timestamp + variable_get('cps_recent_changeset_max_age', 86400) < REQUEST_TIME) {
        unset($_SESSION['touched changesets'][$id]);
      }
      elseif (empty($changesets[$id])) {
        $recent_ids[] = $id;
      }
    }

    if ($recent_ids) {
      $entities = cps_changeset_load_multiple($recent_ids);
      $uids = array();
      foreach ($entities as $entity) {
        $uids[] = $entity->uid;
      }

      $accounts = user_load_multiple($uids);
      foreach ($entities as $id => $entity) {
        if ($entity->uid == $user->uid) {
          $my_published[$id] = $entity->name;
        }
        else {
          $recent[format_username($accounts[$entity->uid])][$id] = $entity->name;
        }
      }      
    }
  }

  // Live changeset is always on top.
  $retval = $published;

  // Now my open changesets.
  if ($changesets) {
    $retval += array(t('My open site versions') => $changesets);
  }

  // My published if I've looked at them recently.
  if ($my_published) {
    $retval += array(t('My published') => $my_published);
  }

  // And other people's changesets if I've been looking at them.
  if ($recent) {
    asort($recent);
    $retval += $recent;
  }

  return $retval;
}

/**
 * Fetch a list of possible states for changesets.
 *
 * @return string[]
 *   An array of state named keyed by the internal name.
 */
function cps_changeset_get_states() {
  $states = array(
    'unpublished' => t('Unpublished'),
    'archived' => t('Archived'),
  );

  drupal_alter('cps_changeset_states', $states);
  return $states;
}

/**
 * Page callback to render a revisions page.
 *
 * This can be added via hook_menu by any module implementing CPS support
 * for an entity to override the revisions page and show a CPS friendly
 * version of it.
 *
 * @param string $entity_type
 *   The entity type of the entity.
 * @param object $entity
 *   The entity to display revisions for.
 *
 * @return array
 *   A Drupal renderable array of the page.
 */
function cps_show_revisions_page($entity_type, $entity) {
  // @todo: no real need for a wrapper here.
  if (cps_is_supported($entity_type)) {
    cps_revisions_page($entity, $entity_type);
  }

  return array();
}

/**
 * Provide a warning message if the entity has unpublished changes in another changeset.
 *
 * @param object $entity
 *   The entity to test.
 *
 * @return string|null
 *   A warning string or null.
 */
function cps_changeset_edit_warning($entity) {
  // $entity->changeset will only contain unpublished revisions.
  if (empty($entity->changeset)) {
    return;
  }

  foreach (array_keys($entity->changeset) as $id) {
    // Ignore the current changeset.
    if ($id == cps_get_current_changeset()) {
      continue;
    }

    // If anything else pops, put up a warning.
    return t('Warning, this content has unpublished changes in another site version! Whichever site version is published LAST will overwrite the other. Please see the History tab for details to help coordinate your changes.');
  }
}

/**
 * Creates an array of rows which represent the difference between nodes.
 *
 * This function relies on the diff module. It is largely copied from
 * _diff_body_rows() which is unnecessarily node specific.
 * 
 * @param string $entity_type
 *   The entity type to compare.
 * @param object $old
 *   Node for comparison which will be displayed on the left side.
 * @param object $new
 *   Node for comparison which will be displayed on the right side.
 * @param string $state
 *   The state to render for the diff.
 * 
 * @return array
 *   The rows of the diff.
 */
function cps_diff($entity_type, $old, $new, $state = 'raw') {
  if (!module_exists('diff')) {
    return FALSE;
  }

  // This is an unique index only, so no need for drupal_static().
  static $table_row_counter = 0;

  if ($theme = variable_get('diff_theme', 'default')) {
    drupal_add_css(drupal_get_path('module', 'diff') . "/css/diff.{$theme}.css");
  }
  module_load_include('inc', 'diff', 'diff.pages');

  $rows = array();
  $any_visible_change = FALSE;

  // Some special handling if the old version is the special unpublished
  // live revision.

  $is_new = FALSE;
  if (property_exists($old, 'log')) {
    if ($old->log == 'Initial live revision') {
      $is_new = TRUE;
    }
  }
  elseif ($old->timestamp == $old->created) {
    // If it doesn't support the log property, as files do not,
    // it is a bit tougher to determine if it's newly created. But
    // it can be done.
    if (entity_status_supported($entity_type) && entity_status_get($entity_type, $entity)) {
      $is_new = TRUE;
    }
  }

  if (!$is_new) {
    $context = array(
      'entity_type' => $entity_type,
      'states' => array($state),
      'view_mode' => 'diff_standard',
    );

    $diffs = diff_compare_entities($old, $new, $context);

    // Track line numbers between multiple diffs.
    $line_stats = array(
      'counter' => array('x' => 0, 'y' => 0),
      'offset' => array('x' => 0, 'y' => 0),
    );

    // Render diffs for each.
    foreach ($diffs as $diff) {
      $show_header = !empty($diff['#name']);
      // These are field level settings.
      if ($show_header && isset($diff['#settings']['show_header'])) {
        $show_header = $show_header && $diff['#settings']['show_header'];
      }

      // Line counting and line header options.
      if (empty($diff['#settings']['line_counter'])) {
        $line_counter = FALSE;
      }
      else {
        $line_counter = $diff['#settings']['line_counter'];
      }
      // Every call to 'line' resets the counters.
      if ($line_counter) {
        $line_stats['counter']['x'] = 0;
        $line_stats['counter']['y'] = 0;
        if ($line_counter == 'line' && 0) {
          $line_stats['offset']['x'] = 0;
          $line_stats['offset']['y'] = 0;
        }
        $line_stats_ref = $line_stats;
      }
      else {
        $line_stats_ref = NULL;
      }

      list($old_content, $new_content) = diff_extract_state($diff, $state);
      if ($diff_rows = diff_get_rows($old_content, $new_content, $line_counter && $line_counter != 'hidden', $line_stats_ref)) {
        if ($line_counter && $line_counter != 'line') {
          $line_stats['offset']['x'] += $line_stats_ref['counter']['x'];
          $line_stats['offset']['y'] += $line_stats_ref['counter']['y'];
        }
        if ($show_header) {
          $rows['diff-header-' . $table_row_counter++] = array(
            array(
              'data' => t('Changes to %name', array('%name' => $diff['#name'])),
              'class' => 'diff-section-title',
              'colspan' => 4,
            ),
          );
        }
        // To avoid passing counter to the Diff engine, index rows manually here
        // to allow modules to interact with the table. i.e. no array_merge().
        foreach ($diff_rows as $row) {
          $rows['diff-row-' . $table_row_counter++] = $row;
        }
        $any_visible_change = TRUE;
      }
    }
  }

  if (!$any_visible_change) {
    $rows['diff-empty-' . $table_row_counter++] = array(
      array(
        'data' => !$is_new ? t('No visible changes') : t('Newly created'),
        'class' => 'diff-section-title',
        'colspan' => 4,
      ),
    );
    // @todo: revise this.
    // Needed to keep safari happy.
    $rows['diff-empty-' . $table_row_counter++] = array(
      array('data' => ''),
      array('data' => ''),
      array('data' => ''),
      array('data' => ''),
    );
  }

  return $rows;
}

/**
 * Render a diff between two entities of the same type.
 *
 * @param string $entity_type
 *   The entity type to compare.
 * @param object $old
 *   Node for comparison which will be displayed on the left side.
 * @param object $new
 *   Node for comparison which will be displayed on the right side.
 * @param string $state
 *   The state to render for the diff.
 *
 * @return array
 *   An array suitable for drupal_render().
 */
function cps_render_diff($entity_type, $old, $new, $state = 'raw') {
  if (!module_exists('diff')) {
    return array();
  }

  // cps_diff can be long if there's a LOT of content, so let's add some time.
  drupal_set_time_limit(30);
  $rows = cps_diff($entity_type, $old, $new, $state);
  $header = array();

  $build = array(
    '#theme' => 'table__diff__standard',
    '#header' => $header,
    '#rows' => $rows,
    '#attributes' => array('class' => array('diff')),
    '#colgroups' => _diff_default_cols(),
    '#sticky' => FALSE,
    '#changes' => 0,
  );


  foreach (array_keys($rows) as $key) {
    if (strpos($key, 'diff-row-') === 0) {
      $build['#changes']++;
    }
  }

  // diff puts a blank line at the end which is keyed like a change, though
  // it is not. Discount this.
  if ($build['#changes'] > 1) {
    $build['#changes']--;
  }

  return $build;
}

/**
 * Render a change into a changeset's entity view.
 *
 * @param string $entity_type
 *   The type of entity being rendered.
 * @param object $change
 *   The changed entity being rendered.
 * @param CPSChangeset $entity
 *   The changeset this is for.
 * @return array
 *   An array suitable for drupal_render().
 */
function cps_render_changed_entity($entity_type, $change, $entity) {
  list($entity_id, , $bundle) = entity_extract_ids($entity_type, $change);
  $uri = entity_uri($entity_type, $change);
  $changeset_uri = $entity->uri();

  // Don't render diff for published changesets:
  if (!$entity->published) {
    // We can't actually trust $change->published_revision because it might have
    // loaded incompletely, so let's load a fresh version.

    // Make sure that CPS doesn't swap out the entity it loads!
    cps_override_changeset(CPS_PUBLISHED_CHANGESET);
    $original = entity_load_single($entity_type, $entity_id);
    cps_override_changeset(NULL);

    if ($original && (!property_exists($original, 'log') || $original->log != 'Initial live revision')) {
      $diff = cps_render_diff($entity_type, $original, $change);
      if (!empty($diff['#changes'])) {
        $title = format_plural($diff['#changes'], '1 change', '@count changes');
      }
      else {
        // If there are no changes, we should get either new entity or no visible changes.
        if ($diff) {
          $title = reset($diff['#rows']);
          $title = $title[0]['data'];
        }
        else {
          $title = t('No visible changes');
        }
      }
    }
    else {
      $diff = array();
      $title = t('Newly created');
    }
  }
  else {
    $diff = array();
    $title = t('No diffs for published site versions');
  }

  $can_edit = cps_can_edit_entities('update', $entity_type, $change, $entity->changeset_id);

  $entity_info = entity_get_info($entity_type);
  $build = array(
    '#entity' => $change,
    'top' => array(
      '#prefix' => '<tr class="even">',
      'title' => array(
        '#prefix' => '<td class="cps-title">',
        '#markup' => check_plain(entity_label($entity_type, $change)),
        '#suffix' => '</td>',
      ),
      'bundle' => array(
        '#prefix' => '<td class="cps-bundle">',
        '#markup' => $entity_info['bundles'][$bundle]['label'],
        '#suffix' => '</td>',
      ),
      'operations' => array(
        '#prefix' => '<td class="cps-operations">',
        'view' => array(
          '#theme' => 'link',
          '#text' => t('view'),
          '#path' => $uri['path'],
          '#options' => array(
            'query' => array('changeset_id' => $entity->changeset_id),
            'html' => TRUE,
            'attributes' => array('class' => array('cps-changeset-operation')),
          ),
        ),
        'remove' => array(
          '#theme' => 'link',
          '#text' => t('remove from site version'),
          '#path' => $changeset_uri['path'] . '/remove/' . $entity_type . '/' . $entity_id,
          '#options' => array(
            'query' => drupal_get_destination(),
            'html' => TRUE,
            'attributes' => array('class' => array('cps-changeset-operation')),
          ),
          '#access' => $can_edit,
        ),
        'move' => array(
          '#theme' => 'link',
          '#text' => $can_edit ? t('move/copy to current site version') : t('copy to current site version'),
          '#path' => $changeset_uri['path'] . '/move/' . $entity_type . '/' . $entity_id,
          '#options' => array(
            'query' => drupal_get_destination(),
            'html' => TRUE,
            'attributes' => array('class' => array('cps-changeset-operation')),
          ),
          '#access' => cps_can_edit_entities('move to', $entity_type, $change) && $entity->changeset_id != cps_get_current_changeset(),
        ),
        '#suffix' => '</td>',
      ),
      '#suffix' => '</tr>',
    ),
    'bottom' => array(
      '#prefix' => '<tr class="odd"><td colspan="3" class="cps-changes"><div class="ctools-collapsible-container ctools-collapsed">',
      'title' => array(
        '#prefix' => '<div class="ctools-collapsible-handle">',
        '#markup' => $title,
        '#suffix' => '</div>',
      ),
      'changes' => array(
        '#prefix' => '<div class="ctools-collapsible-content">',
        'diff' => $diff,
        '#suffix' => '</div>',
      ),
      '#suffix' => '</div></td></tr>',
    ),
    '#suffix' => '</div>',
  );

  return $build;
}

/**
 * Lock the CPS publishing system.
 *
 * @return bool
 *   TRUE if the lock can be acquired. FALSE if not.
 *
 * @see cps_publish_lock_time()
 */
function cps_publish_lock() {
  $time = cps_publish_lock_time();
  if ($time) {
    return FALSE;
  }
  // Set the lock to expire in 30 minutes.
  // This seems like a long time, but some publishing runs can be quite long, and we want
  // to make sure they finish and that a timeout truly represents an aborted publishing job,
  // for example because the user navigated away from the batch job before it completed.
  variable_set('cps_publishing_lock', REQUEST_TIME + variable_get('cps_publishing_lock_expire', 60 * 30));
  return TRUE;
}

/**
 * Unlock the CPS publishing system.
 */
function cps_publish_unlock() {
  variable_del('cps_publishing_lock');
}

/**
 * Test the CPS publishing lock.
 *
 * @return int
 *   The number of seconds remaining if publishing is locked, FALSE if it is not.
 */
function cps_publish_lock_time() {
  $lock = variable_get('cps_publishing_lock', 0);
  if ($lock > REQUEST_TIME) {
    return $lock - REQUEST_TIME;
  }

  return FALSE;
}

// -------------------------------------------------------------------------
// Database and general entity API functions

/**
 * Changeset entity loader.
 *
 * @param string $changeset_id
 *   The changeset id.
 *
 * @return CPSChangeset
 *   The changeset, if found.
 *
 * @see entity_load()
 */
function cps_changeset_load($changeset_id) {
  $entities = cps_changeset_load_multiple(array($changeset_id));
  if ($entities) {
    return reset($entities);
  }
}

/**
 * Load multiple changesets.
 *
 * @param string[] $ids
 *   An array of IDs to load.
 * @param array $conditions
 *   (optional) An array of conditions.
 * @param bool $reset
 *   (optional) TRUE to force a load from database.
 *
 * @see entity_load_multiple()
 */
function cps_changeset_load_multiple($ids, $conditions = array(), $reset = FALSE) {
  return entity_load('cps_changeset', $ids, $conditions, $reset);
}

/**
 * Save a changeset entity.
 *
 * @param CPSChangeset $entity
 *   The entity to save.
 *
 * @see node_save()
 */
function cps_changeset_save(CPSChangeset $entity) {
  return entity_get_controller('cps_changeset')->save($entity);
}

/**
 * Delete a changeset entity.
 *
 * @param $changeset_id
 *   A changeset ID.
 */
function cps_changeset_delete($changeset_id) {
  cps_changeset_delete_multiple(array($changeset_id));
}

/**
 * Delete a revision for a changeset entity.
 *
 * @param $vid
 *   The revision id to delete.
 */
function cps_changeset_delete_revision($vid) {
  return entity_get_controller('cps_changeset')->deleteRevision($vid);
}

/**
 * Delete multiple changesets.
 *
 * @param string[] $changeset_ids
 *   An array of changeset IDs.
 */
function cps_changeset_delete_multiple(array $changeset_ids) {
  return entity_get_controller('cps_changeset')->delete($changeset_ids);
}

/**
 * View a changeset entity.
 *
 * @param CPSChangeset $entity
 *   The changeset entity.
 * @param string $view_mode
 *   The view mode to view.
 * @param string $langcode
 *   The language to use or NULL.
 *
 * @return array
 *   A Drupal renderable array.
 *
 * @see node_view()
 */
function cps_changeset_view(CPSChangeset $entity, $view_mode = 'full', $langcode = NULL) {
  return entity_get_controller('cps_changeset')->view($entity, $view_mode, $langcode);
}

/**
 * Callback to create a new entity.
 *
 * @param array $values
 *   The initial values to seed the new entity with.
 *
 * @return CPSChangeset
 */
function cps_changeset_create($values = array()) {
  return entity_get_controller('cps_changeset')->create($values);
}

/**
 * Determine if the operation for the entity can be accessed.
 *
 * @param string $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'. It may also be any changeset operation such as 'publish' or
 *   'unpublish'.
 * @param string|CPSChangeset $entity
 *   (optional) an entity to check access for. If no entity is given, it will be
 *   determined whether access is allowed for all entities of the given type.
 * @param stdClass|null $account
 *   The user to check for. Leave it to NULL to check for the global user.
 *
 * @return boolean
 *   Whether access is allowed or not. If the entity type does not specify any
 *   access information, NULL is returned.
 *
 * @see entity_access()
 */
function cps_changeset_access($op, $entity = NULL, $account = NULL) {
  return entity_get_controller('cps_changeset')->access($op, $entity, $account);
}

/**
 * Callback for getting content properties.
 *
 * @param CPSChangeset $changeset
 *   The changeset entity to get proprties for.
 * @param array $options
 *   The options provided by the caller.
 * @param $name
 *   The name of the property.
 *
 * @return mixed
 *   The result of the property.
 */
function cps_changeset_metadata_get_properties(CPSChangeset $changeset, array $options, $name) {
  switch ($name) {
    case 'is_new':
      return empty($changeset->changeset_id) || !empty($changeset->is_new);

    case 'edit_url':
      return url('admin/structure/changesets/' . $changeset->changeset_id . '/edit', $options);

    case 'delete_url':
      return url('admin/structure/changesets/' . $changeset->changeset_id . '/delete', $options);

    case 'author':
      return !empty($changeset->uid) ? $changeset->uid : drupal_anonymous_user();

    case 'operations':
      $build = cps_changeset_get_operations($changeset);
      return drupal_render($build);
  }
}

/**
 * Fetch a renderable array of changeset operations available for the changeset.
 *
 * @param CPSChangeset $changeset
 *   The changeset to get operations for.
 *
 * @return array
 *   A drupal Renderable array.
 */
function cps_changeset_get_operations(CPSChangeset $changeset) {
  $uri = $changeset->uri();
  $operations = array(
    '#type' => 'container',
    '#attributes' => array('class' => 'cps-changeset-operations'),
    'site' => array(
      '#theme' => 'link',
      '#text' => t('view site'),
      '#path' => '<front>',
      '#options' => array(
        'query' => array('changeset_id' => $changeset->changeset_id),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => user_access('preview changesets') || user_access('view changesets') || user_access('administer changesets'),
    ),
    'view' => array(
      '#theme' => 'link',
      '#text' => t('status'),
      '#path' => $uri['path'],
      '#options' => array(
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('view', 'cps_changeset', $changeset) && request_path() != $uri['path'],
    ),
    'edit' => array(
      '#theme' => 'link',
      '#text' => t('edit'),
      '#path' => $uri['path'] . '/edit',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('update', 'cps_changeset', $changeset),
    ),
    'delete' => array(
      '#theme' => 'link',
      '#text' => t('delete'),
      '#path' => $uri['path'] . '/delete',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('delete', 'cps_changeset', $changeset),
    ),
    'publish' => array(
      '#theme' => 'link',
      '#text' => t('publish'),
      '#path' => $uri['path'] . '/publish',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('publish', 'cps_changeset', $changeset),
    ),
    'unpublish' => array(
      '#theme' => 'link',
      '#text' => t('unpublish'),
      '#path' => $uri['path'] . '/unpublish',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('unpublish', 'cps_changeset', $changeset),
    ),
  );

  drupal_alter('cps_changeset_operations', $operations, $changeset);
  return $operations;
}

/**
 * Return a list of revisions with CPS information for the entity.
 *
 * @param object $entity
 *   The entity to find changesets for.
 * @return CPSChangeset[]
 *   An array of changesets, keyed by the revision ID they apply to..
 */
function entity_revision_list($entity, $entity_type) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);
  $live_revision_id = isset($entity->published_revision_id) ? $entity->published_revision_id : $revision_id;

  $entity_info = entity_get_info($entity_type);
  $revision_table = $entity_info['revision table'];
  $id_key = $entity_info['entity keys']['id'];
  $revision_key = $entity_info['entity keys']['revision'];

  $query = db_select('cps_entity', 'c')->extend('PagerDefault');
  $query->limit(25);
  $query->join($revision_table, 'r', "c.revision_id = r.$revision_key");
  $query->join('cps_changeset', 'cc', "cc.changeset_id = c.changeset_id");
  $query->fields('c', array('changeset_id', 'revision_id'))
    ->condition('c.entity_type', $entity_type)
    ->condition("r.$id_key", $entity_id)
    // We also only include where c.published IS NULL, because if it's set
    // that means the entry was added when a changeset was published to
    // preserve the site state at the time it was published and is not relevant
    // here.
    ->isNull('c.published')
    // the "initial" revision is a special one created to ensure that content
    // isn't accidentally visible on the site until published, and is not
    // relevant to show.
    ->condition('c.changeset_id', 'initial', '<>')
    // Live revision is always first.
    ->orderBy('CASE WHEN c.revision_id = ' . $live_revision_id . ' THEN 0 ELSE 1 END')
    // Then unpublished revisions.
    ->orderBy('CASE WHEN cc.published = 0 THEN 0 ELSE 1 END')
    // Then order by publish date.
    ->orderBy('cc.published', 'DESC')
    // And finally as a backup, by revision id.
    ->orderBy("r.$revision_key", 'DESC');

  $result = $query->execute();

  $keys = array();
  foreach ($result as $revision) {
    $keys[$revision->changeset_id] = $revision->revision_id;
  }

  $changesets = array();
  foreach (cps_changeset_load_multiple(array_keys($keys)) as $changeset_id => $changeset) {
    $changesets[$keys[$changeset_id]] = $changeset;
  }
  return $changesets;
}

/**
 * Page callback to show revisions for an entity.
 */
function cps_revisions_page($entity, $entity_type) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);

  $live_revision_id = isset($entity->published_revision_id) ? $entity->published_revision_id : $revision_id;

  $uri = entity_uri($entity_type, $entity);
  drupal_set_title(t('History for %title', array('%title' => entity_label($entity_type, $entity))), PASS_THROUGH);

  $status_options = cps_changeset_get_states();
  $changesets = cps_revision_list($entity);

  $rows = array();
  // System created entities might not have a live revision. If not,
  // create a fake entry to inform the user.
  if (empty($changesets)) {
    $rows[] = array(
      t('System created'),
      t('System created'),
      '<b>' . t('Live') . '</b>',
      ''
    );
  }

  foreach ($changesets as $changeset_revision_id => $changeset) {
    $row = array();
    $changeset_uri = $changeset->uri();
    $row[] = l($changeset->label(), $changeset_uri['path']);
    $row[] = format_username($changeset);

    if ($changeset_revision_id == $live_revision_id) {
      $status = '<b>' . t('Live') . '</b>';
    }
    else {
      $status = $status_options[$changeset->status];
    }

    if (!empty($changeset->published)) {
      $status .= '<br/>' . t('Published on @date', array('@date' => format_date($changeset->published)));
    }

    $row[] = $status;

    $operations = array(
      '#type' => 'container',
      '#attributes' => array('class' => 'cps-changeset-operations'),
      'site' => array(
        '#theme' => 'link',
        '#text' => t('view'),
        '#path' => $uri['path'],
        '#options' => array(
          'query' => array('changeset_id' => $changeset->changeset_id),
          'html' => TRUE,
          'attributes' => array('class' => array('cps-changeset-operation'))
        ),
        '#access' => user_access('preview changesets') || user_access('view changesets') || user_access('administer changesets'),
      ),
    );

    $row[] = drupal_render($operations);

    $rows[] = $row;
  }

  $header = array(t('Site version'), t('Author'), t('Status'), t('Operations'));

  $build['entity_revisions_table'] = array(
    '#theme' => 'table',
    '#rows' => $rows,
    '#header' => $header,
  );

  // Attach the pager theme.
  $build['entity_revisions_table_pager'] = array('#theme' => 'pager');

  return $build;
}
