<?php

/**
 * @file
 * Main module file to add CPS support to nodes.
 */

// -----------------------------------------------------------------------
// Contrib Hooks

/**
 * Implements hook_ctools_plugin_directory().
 */
function cps_node_ctools_plugin_directory($module, $plugin) {
  if ($module == 'cps') {
    return 'plugins/' . $plugin;
  }
}

// -----------------------------------------------------------------------
// Drupal Core Hooks

/**
 * Implements hook_menu_alter().
 */
function cps_node_menu_alter(&$items) {
  // Disable access to the revisions page entirely.
  // @todo diff module is messing this up.
  $items['node/%node/revisions']['access callback'] = FALSE;

  // And add our history page in its stead.
  $items['node/%node/history'] = array(
    'title' => 'History',
    'page callback' => 'cps_show_revisions_page',
    'page arguments' => array('node', 1),
    'access callback' => '_node_revision_access',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK,
  );

}

/**
 * Implements hook_node_access().
 */
function cps_node_node_access($node, $op, $account) {
  // Special check for unpublished content:
  // No node content with status 0 (unpublished) should be visible
  // when viewing the published changeset.
  $changeset = cps_get_current_changeset(TRUE);
  if ($changeset == CPS_PUBLISHED_CHANGESET && is_object($node) && $node->status == NODE_NOT_PUBLISHED) {
    return NODE_ACCESS_DENY;
  }

  if (!cps_can_edit_entities($op, 'node', $node)) {
    return NODE_ACCESS_DENY;
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_form_node_form_alter().
 */
function cps_node_form_node_form_alter(&$form, &$form_state, &$form_id) {
  $form['revision_information']['#access'] = FALSE;
  $form['actions']['submit']['#submit'][] = 'cps_node_node_form_submit';
}

/**
 * Submit callback for the node handler.
 */
function cps_node_node_form_submit($form, &$form_state) {
  // Because of revision management in changesets, the aliased path can become invalid
  // when CPS re-saves the published revision. Force it to go to the unaliased path
  // to ensure that it always goes to the right place.
  if (!empty($form_state['redirect']) && !is_array($form_state['redirect'])) {
    $form_state['redirect'] = array($form_state['redirect'], array('alias' => TRUE));
  }
}

function cps_node_admin_paths() {
  return array(
    'node/*/history' => TRUE,
  );
}

/**
 *  Implements hook_module_implements_alter().
 */
function cps_node_module_implements_alter(&$implementations, $hook) {
  if (isset($implementations['cps_node']) && ($hook == 'query_alter')) {
    // Move CPS's query alter after entity reference's so we can remove the
    // checks for published status.
    $group = $implementations['cps_node'];
    unset($implementations['cps_node']);
    $implementations['cps_node'] = $group;
  }
}

/**
 *  Implements hook_query_TAG_alter().
 */
function cps_node_query_entityreference_alter(QueryAlterableInterface $query) {
  // If the user can view changesets, then they need to be able to reference
  // unpublished nodes when in a changeset context.
  $tables = $query->getTables();
  // If cps_entity is not added there is very little we can do at this point.
  if (cps_get_current_changeset(TRUE) != CPS_PUBLISHED_CHANGESET && isset($tables['cps_entity'])) {
    $conditions = &$query->conditions();
    foreach ($conditions as $index => $condition) {
      // EntityReference_SelectionHandler_Generic_node::entityFieldQueryAlter()
      // adds this condition.
      if (is_array($condition) && $condition['field'] == 'node.status' && $condition['operator'] == '=') {
        unset($conditions[$index]);
        if (!isset($tables['node_revision'])) {
          $query->join('node_revision', 'node_revision', 'node_revision.vid = COALESCE(cps_entity.revision_id, node.vid)');
        }
        $query->condition('node_revision.status', $condition['value']);
        break;
      }
    }
  }
}
